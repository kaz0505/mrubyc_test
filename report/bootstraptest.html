<html>
<head>
  <meta charset='utf-8' />
  <title>mruby/c basictest report</title>
</head>
<body>

  
    <div>
      <h2>test_string.out</h2>
      <pre style='float: left; width: 50%'>assert_normal_exit %q{
  inspect.clear
}, &#39;[ruby-core:68110]&#39;
</pre>
      <pre>no method(assert_normal_exit)!
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_attr.out</h2>
      <pre style='float: left; width: 50%'>assert_equal &#39;ok&#39;, %q{
  module M
    class A
      class &lt;&lt; self
        attr_accessor :at
        def workflow_rule
          yield self
        end

        def eval_str(str)
          eval(str)
        end
      end
    end
  end
  begin
    M::A.eval_str(&lt;&lt;-END)
    workflow_rule do |r|
      r.at 1
    end
    END
  rescue ArgumentError =&gt; e
    print &quot;ok&quot;
  end
}, &#39;[ruby-core:14641]&#39;

assert_equal %{ok}, %{
  class A
    attr :m
  end
  begin
    A.new.m(3)
  rescue ArgumentError =&gt; e
    print &quot;ok&quot;
  end
}, &#39;[ruby-core:15120]&#39;
</pre>
      <pre>no method(to_s)!
ng: ok
no method(to_s)!
ng: ok
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_load.out</h2>
      <pre style='float: left; width: 50%'>assert_equal &#39;ok&#39;, %q{
  open(&quot;require-lock-test.rb&quot;, &quot;w&quot;) {|f|
    f.puts &quot;sleep 0.1&quot;
    f.puts &quot;module M&quot;
    f.puts &quot;end&quot;
  }
  $:.unshift Dir.pwd
  vs = (1..2).map {|i|
    Thread.start {
      require &quot;require-lock-test&quot;
      M
    }
  }.map {|t| t.value }
  vs[0] == M &amp;&amp; vs[1] == M ? :ok : :ng
}, &#39;[ruby-dev:32048]&#39;

assert_equal &#39;ok&#39;, %q{
  %w[a a/foo b].each {|d| Dir.mkdir(d)}
  open(&quot;b/foo&quot;, &quot;w&quot;) {|f| f.puts &quot;$ok = :ok&quot;}
  $:.replace(%w[a b])
  begin
    load &quot;foo&quot;
    $ok
  rescue =&gt; e
    e.message
  end
}, &#39;[ruby-dev:38097]&#39;
</pre>
      <pre>no method(to_s)!
ng: ok
no method(to_s)!
ng: ok
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_io.out</h2>
      <pre style='float: left; width: 50%'>assert_finish 5, %q{
  r, w = IO.pipe
  t1 = Thread.new { r.sysread(1) }
  t2 = Thread.new { r.sysread(1) }
  sleep 0.01 until t1.stop? and t2.stop?
  w.write &quot;a&quot;
  w.write &quot;a&quot;
}, &#39;[ruby-dev:31866]&#39;

assert_finish 10, %q{
  begin
    require &quot;io/nonblock&quot;
    require &quot;timeout&quot;
    timeout(3) do
      r, w = IO.pipe
      w.nonblock?
      w.nonblock = true
      w.write_nonblock(&quot;a&quot; * 100000)
      w.nonblock = false
      t1 = Thread.new { w.write(&quot;b&quot; * 4096) }
      t2 = Thread.new { w.write(&quot;c&quot; * 4096) }
      sleep 0.5
      r.sysread(4096).length
      sleep 0.5
      r.sysread(4096).length
      t1.join
      t2.join
    end
  rescue LoadError, Timeout::Error, NotImplementedError
  end
}, &#39;[ruby-dev:32566]&#39;

assert_finish 1, %q{
  r, w = IO.pipe
  Thread.new {
    w &lt;&lt; &quot;ab&quot;
    sleep 0.01
    w &lt;&lt; &quot;ab&quot;
  }
  r.gets(&quot;abab&quot;)
}

assert_equal &#39;ok&#39;, %q{
  require &#39;tmpdir&#39;
  begin
    tmpname = &quot;#{Dir.tmpdir}/ruby-btest-#{$$}-#{rand(0x100000000).to_s(36)}&quot;
    rw = File.open(tmpname, File::RDWR|File::CREAT|File::EXCL)
  rescue Errno::EEXIST
    retry
  end
  save = STDIN.dup
  STDIN.reopen(rw)
  STDIN.reopen(save)
  rw.close
  File.unlink(tmpname) unless RUBY_PLATFORM[&#39;nacl&#39;]
  :ok
}

assert_equal &#39;ok&#39;, %q{
  require &#39;tmpdir&#39;
  begin
    tmpname = &quot;#{Dir.tmpdir}/ruby-btest-#{$$}-#{rand(0x100000000).to_s(36)}&quot;
    rw = File.open(tmpname, File::RDWR|File::CREAT|File::EXCL)
  rescue Errno::EEXIST
    retry
  end
  save = STDIN.dup
  STDIN.reopen(rw)
  STDIN.print &quot;a&quot;
  STDIN.reopen(save)
  rw.close
  File.unlink(tmpname) unless RUBY_PLATFORM[&#39;nacl&#39;]
  :ok
}

assert_equal &#39;ok&#39;, %q{
  dup = STDIN.dup
  dupfd = dup.fileno
  dupfd == STDIN.dup.fileno ? :ng : :ok
}, &#39;[ruby-dev:46834]&#39;

assert_normal_exit %q{
  ARGF.set_encoding &quot;foo&quot;
}

10.times do
  assert_normal_exit %q{
    at_exit { p :foo }

    megacontent = &quot;abc&quot; * 12345678
    #File.open(&quot;megasrc&quot;, &quot;w&quot;) {|f| f &lt;&lt; megacontent }

    t0 = Thread.main
    Thread.new { sleep 0.001 until t0.stop?; Process.kill(:INT, $$) }

    r1, w1 = IO.pipe
    r2, w2 = IO.pipe
    t1 = Thread.new { w1 &lt;&lt; megacontent; w1.close }
    t2 = Thread.new { r2.read; r2.close }
    IO.copy_stream(r1, w2) rescue nil
    w2.close
    r1.close
    t1.join
    t2.join
  }, &#39;megacontent-copy_stream&#39;, [&quot;INT&quot;], :timeout =&gt; 10 or break
end

assert_normal_exit %q{
  r, w = IO.pipe
  STDOUT.reopen(w)
  STDOUT.reopen(__FILE__, &quot;r&quot;)
}, &#39;[ruby-dev:38131]&#39;
</pre>
      <pre>no method(assert_finish)!
Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_literal_suffix.out</h2>
      <pre style='float: left; width: 50%'># numbers with suffix
assert_equal &#39;0/1&#39;,             &#39;0r&#39;
assert_equal &#39;Rational&#39;,        &#39;0r.class&#39;
assert_equal &#39;1/1&#39;,             &#39;1r&#39;
assert_equal &#39;Rational&#39;,        &#39;1r.class&#39;
assert_equal &#39;-1/1&#39;,            &#39;-1r&#39;
assert_equal &#39;Rational&#39;,        &#39;(-1r).class&#39;
assert_equal &#39;1/1&#39;,             &#39;0x1r&#39;
assert_equal &#39;Rational&#39;,        &#39;0x1r.class&#39;
assert_equal &#39;1/1&#39;,             &#39;0b1r&#39;
assert_equal &#39;Rational&#39;,        &#39;0b1r.class&#39;
assert_equal &#39;1/1&#39;,             &#39;0d1r&#39;
assert_equal &#39;Rational&#39;,        &#39;0d1r.class&#39;
assert_equal &#39;1/1&#39;,             &#39;0o1r&#39;
assert_equal &#39;Rational&#39;,        &#39;0o1r.class&#39;
assert_equal &#39;1/1&#39;,             &#39;01r&#39;
assert_equal &#39;Rational&#39;,        &#39;01r.class&#39;
assert_equal &#39;6/5&#39;,             &#39;1.2r&#39;
assert_equal &#39;Rational&#39;,        &#39;1.2r.class&#39;
assert_equal &#39;-6/5&#39;,            &#39;-1.2r&#39;
assert_equal &#39;Rational&#39;,        &#39;(-1.2r).class&#39;
assert_equal &#39;0+0i&#39;,            &#39;0i&#39;
assert_equal &#39;Complex&#39;,         &#39;0i.class&#39;
assert_equal &#39;0+1i&#39;,            &#39;1i&#39;
assert_equal &#39;Complex&#39;,         &#39;1i.class&#39;
assert_equal &#39;0+1i&#39;,            &#39;0x1i&#39;
assert_equal &#39;Complex&#39;,         &#39;0x1i.class&#39;
assert_equal &#39;0+1i&#39;,            &#39;0b1i&#39;
assert_equal &#39;Complex&#39;,         &#39;0b1i.class&#39;
assert_equal &#39;0+1i&#39;,            &#39;0d1i&#39;
assert_equal &#39;Complex&#39;,         &#39;0d1i.class&#39;
assert_equal &#39;0+1i&#39;,            &#39;0o1i&#39;
assert_equal &#39;Complex&#39;,         &#39;0o1i.class&#39;
assert_equal &#39;0+1i&#39;,            &#39;01i&#39;
assert_equal &#39;Complex&#39;,         &#39;01i.class&#39;
assert_equal &#39;0+1.2i&#39;,          &#39;1.2i&#39;
assert_equal &#39;Complex&#39;,         &#39;1.2i.class&#39;
assert_equal &#39;0+1/1i&#39;,          &#39;1ri&#39;
assert_equal &#39;Complex&#39;,         &#39;1ri.class&#39;
assert_equal &#39;0+6/5i&#39;,          &#39;1.2ri&#39;
assert_equal &#39;Complex&#39;,         &#39;1.2ri.class&#39;
assert_equal &#39;0+10.0i&#39;,         &#39;1e1i&#39;
assert_equal &#39;Complex&#39;,         &#39;1e1i.class&#39;
assert_equal &#39;1&#39;,               &#39;1if true&#39;
assert_equal &#39;1&#39;,               &#39;1rescue nil&#39;
assert_equal &#39;10000000000000000001/10000000000000000000&#39;,
             &#39;1.0000000000000000001r&#39;

assert_equal &#39;syntax error, unexpected tIDENTIFIER, expecting end-of-input&#39;,
             %q{begin eval(&#39;1ir&#39;, nil, &#39;&#39;, 0); rescue SyntaxError =&gt; e; e.message[/\A:(?:\d+:)? (.*)/, 1] end}
assert_equal &#39;syntax error, unexpected tIDENTIFIER, expecting end-of-input&#39;,
             %q{begin eval(&#39;1.2ir&#39;, nil, &#39;&#39;, 0); rescue SyntaxError =&gt; e; e.message[/\A:(?:\d+:)? (.*)/, 1] end}
assert_equal &#39;syntax error, unexpected tIDENTIFIER, expecting end-of-input&#39;,
             %q{begin eval(&#39;1e1r&#39;, nil, &#39;&#39;, 0); rescue SyntaxError =&gt; e; e.message[/\A:(?:\d+:)? (.*)/, 1] end}
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_jump.out</h2>
      <pre style='float: left; width: 50%'>assert_equal %q{ok}, %q{
  def m
    :ng1
    mm{
      yield
    }
    :ng2
  end

  def mm
    :ng3
    yield
    :ng4
  end

  m{
    break :ok
  }
}
assert_equal %q{ok}, %q{
  3.times{
    break :ok
  }
}
assert_equal %q{}, %q{
  catch(:foo){
    throw :foo
  }
}
assert_equal %q{false}, %q{
  catch(:foo){
    throw :foo, false
  }
}
assert_equal %q{}, %q{
  catch(:foo){
    throw :foo, nil
  }
}
assert_equal %q{ok}, %q{
  catch(:foo){
    throw :foo, :ok
  }
}
assert_equal %q{}, %q{
  catch(:foo){
    1.times{
      throw :foo
    }
  }
}
assert_equal %q{ok}, %q{
  catch(:foo){
    1.times{
      throw :foo, :ok
    }
  }
}
assert_equal %q{ok}, %q{
  catch(:foo){
    catch(:bar){
      throw :foo, :ok
    }
    :ng
  }
}
assert_equal %q{ok}, %q{
  catch(:foo){
    catch(:bar){
      1.times{
        throw :foo, :ok
      }
    }
    :ng
  }
}
assert_equal %q{2}, %q{
  module Enumerable
    def all_?
      self.each{|e|
        unless yield(e)
          return false
        end
      }
      true
    end
  end

  xxx = 0
  [1,2].each{|bi|
    [3,4].each{|bj|
      [true, nil, true].all_?{|be| be}
      break
    }
    xxx += 1
  }
  xxx
}
assert_equal %q{ok}, %q{
  def m
    yield
  end

  m{
    begin
    ensure
      break :ok
    end
  }
}
assert_equal %q{ok}, %q{
  def m
    yield
    :ok
  end
  i=0
  m{
    if i&gt;10
      i*i
    else
      i+=1
      next
    end
  }
}
assert_equal %q{ok}, %q{
  def m
    yield
  end

  m{
    next :ok
  }
}
assert_equal %q{131}, %q{
  def m
    yield + 10
  end
  i=0
  m{
    if i&gt;10
      i*i
    else
      i+=1
      redo
    end
  }
}
assert_equal %q{ok}, %q{
begin
  eval %q{
    1.times{
      retry
    }
  }
rescue SyntaxError
  :ok
end
}
assert_equal %q{3}, %q{
  def m
    return 3
  end
  m
}
assert_equal %q{ok}, %q{
  def m
    :ng1
    mm{
      return :ok
    }
    :ng2
  end

  def mm
    :ng3
    yield
    :ng4
  end
  m
}
assert_equal %q{100}, %q{
  $i = 0
  def m
    begin
      iter{
        return
      }
    ensure
      $i = 100
    end
  end

  def iter
    yield
  end
  m
  $i
}
assert_equal %q{ok}, %q{
  def m
    begin
      raise
    rescue
      return :ok
    end
    :ng
  end
  m
}
assert_equal %q{1}, %q{
  def m
    begin
      raise
    rescue
      return 1
    end
  end

  m
}
assert_equal %q{1}, %q{
  def m
    begin
      #
    ensure
      return 1
    end
  end

  m
}
assert_equal &#39;ok&#39;, %q{
  begin
    catch {|t| throw t, :ok }
  rescue ArgumentError
    :ng
  end
}, &#39;[ruby-dev:31609]&#39;

assert_equal &quot;1&quot;, %q{
  catch do |t|
    begin
      throw t, 1
      2
    ensure
      3
    end
  end
}, &quot;[ruby-dev:31698]&quot;

assert_normal_exit %q{
  f = 0
  1.times do
    begin
      f += 1
    ensure
      redo unless f &gt; 2
    end
  end
}

assert_normal_exit %q{
  -&gt; do
    1.times do
      begin
        raise
      rescue
        return
      end
    end
  end.call
}

assert_normal_exit %q{
  while true
    begin
      raise
      next
    rescue
    end
    break
  end
}, &#39;[ruby-core:28172]&#39;

assert_equal &quot;true&quot;, %q{
  class Object
    def return_eigenclass
      class &lt;&lt; self
        return self
      end
    end
  end
  s = &quot;foo&quot;
  s.return_eigenclass == class &lt;&lt; s; self; end
}, &#39;[ruby-core:21379]&#39;

assert_equal &quot;true&quot;, %q{
  class Object
    def yield_eigenclass
      class &lt;&lt; self
        yield self
      end
    end
  end
  s = &quot;foo&quot;
  s.yield_eigenclass {|c| c == class &lt;&lt; s; self; end }
}, &#39;[ruby-dev:40975]&#39;
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_massign.out</h2>
      <pre style='float: left; width: 50%'>assert_equal &#39;[[1], 2, 3]&#39;, &#39;*v1, (a, b) = [1,[2, 3]]; [v1, a, b]&#39;
assert_equal &#39;[[1], 2, 3]&#39;, &#39;*v1,(*), (a, b) = [1,:x,[2, 3]]; [v1, a, b]&#39;

assert_equal &#39;[]&#39;,          &#39;*a = *nil; a&#39;
assert_equal &#39;[nil]&#39;,       &#39;*a = nil; a&#39;
assert_equal &#39;2&#39;,           &#39;a, a = 1, 2; a&#39;, &quot;[ruby-dev:31522]&quot;
assert_equal &#39;[1, 2]&#39;,      &#39;a, b = 1, 2&#39;
assert_equal &#39;[1, 2]&#39;, %q{
  ans = []
  trace_var(:$a){|v| ans &lt;&lt; v}
  trace_var(:$b){|v| ans &lt;&lt; v}
  $a, $b = 1, 2
  ans
}

assert_equal &#39;ok&#39;, %q{
  r = :ok
  :ng.tap {|(r)|}
  r
}, &#39;[ruby-dev:31507]&#39;

=begin
# generated by this script:

3.times{|i|
  8.times{|e|
    ary = (0...e).to_a
    a,b,c,d,e,f = nil
    vals = %w(a b c d e f)
    vals[i] = &#39;*&#39; + vals[i]
    program = &quot;#{vals.join(&quot;, &quot;)} = *ary&quot;
    eval(program)
    ans = [a,b,c,d,e,f]
    puts %Q{
      assert_equal &quot;#{ans.inspect}&quot;, %q{
        ary = #{ary.inspect}
        #{program}; [a, b, c, d, e, f]
      }}
  }
}
=end

      assert_equal &quot;[[], nil, nil, nil, nil, nil]&quot;, %q{
        ary = []
        *a, b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[[], 0, nil, nil, nil, nil]&quot;, %q{
        ary = [0]
        *a, b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[[], 0, 1, nil, nil, nil]&quot;, %q{
        ary = [0, 1]
        *a, b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[[], 0, 1, 2, nil, nil]&quot;, %q{
        ary = [0, 1, 2]
        *a, b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[[], 0, 1, 2, 3, nil]&quot;, %q{
        ary = [0, 1, 2, 3]
        *a, b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[[], 0, 1, 2, 3, 4]&quot;, %q{
        ary = [0, 1, 2, 3, 4]
        *a, b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[[0], 1, 2, 3, 4, 5]&quot;, %q{
        ary = [0, 1, 2, 3, 4, 5]
        *a, b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[[0, 1], 2, 3, 4, 5, 6]&quot;, %q{
        ary = [0, 1, 2, 3, 4, 5, 6]
        *a, b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[nil, [], nil, nil, nil, nil]&quot;, %q{
        ary = []
        a, *b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, [], nil, nil, nil, nil]&quot;, %q{
        ary = [0]
        a, *b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, [], 1, nil, nil, nil]&quot;, %q{
        ary = [0, 1]
        a, *b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, [], 1, 2, nil, nil]&quot;, %q{
        ary = [0, 1, 2]
        a, *b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, [], 1, 2, 3, nil]&quot;, %q{
        ary = [0, 1, 2, 3]
        a, *b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, [], 1, 2, 3, 4]&quot;, %q{
        ary = [0, 1, 2, 3, 4]
        a, *b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, [1], 2, 3, 4, 5]&quot;, %q{
        ary = [0, 1, 2, 3, 4, 5]
        a, *b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, [1, 2], 3, 4, 5, 6]&quot;, %q{
        ary = [0, 1, 2, 3, 4, 5, 6]
        a, *b, c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[nil, nil, [], nil, nil, nil]&quot;, %q{
        ary = []
        a, b, *c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, nil, [], nil, nil, nil]&quot;, %q{
        ary = [0]
        a, b, *c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, 1, [], nil, nil, nil]&quot;, %q{
        ary = [0, 1]
        a, b, *c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, 1, [], 2, nil, nil]&quot;, %q{
        ary = [0, 1, 2]
        a, b, *c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, 1, [], 2, 3, nil]&quot;, %q{
        ary = [0, 1, 2, 3]
        a, b, *c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, 1, [], 2, 3, 4]&quot;, %q{
        ary = [0, 1, 2, 3, 4]
        a, b, *c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, 1, [2], 3, 4, 5]&quot;, %q{
        ary = [0, 1, 2, 3, 4, 5]
        a, b, *c, d, e, f = *ary; [a, b, c, d, e, f]
      }

      assert_equal &quot;[0, 1, [2, 3], 4, 5, 6]&quot;, %q{
        ary = [0, 1, 2, 3, 4, 5, 6]
        a, b, *c, d, e, f = *ary; [a, b, c, d, e, f]
      }


#
assert_equal &#39;ok&#39;, %q{
  a,s=[],&quot;aaa&quot;
  300.times { a&lt;&lt;s; s=s.succ }
  eval &lt;&lt;-END__
  GC.stress=true
  Fiber.new do
    #{ a.join(&quot;,&quot;) },*zzz=1
  end.resume
  END__
  :ok
}, &#39;[ruby-dev:32581]&#39;

assert_equal &#39;ok&#39;, %q{
  while true
    *, z = 1
    break
  end
  :ok
}, &#39;[ruby-dev:32892]&#39;
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_class.out</h2>
      <pre style='float: left; width: 50%'># class
assert_equal &#39;true&#39;,    %q( class C; end
                            Object.const_defined?(:C) )
assert_equal &#39;Class&#39;,   %q( class C; end
                            C.class )
assert_equal &#39;C&#39;,       %q( class C; end
                            C.name )
assert_equal &#39;C&#39;,       %q( class C; end
                            C.new.class )
assert_equal &#39;C&#39;,       %q( class C; end
                            C.new.class.name )
assert_equal &#39;Class&#39;,   %q( class C; end
                            C.new.class.class )
assert_equal &#39;true&#39;,    %q( Object.__send__(:remove_const, :TrueClass)
                            GC.start
                            true.inspect)
assert_equal &#39;false&#39;,   %q( Object.__send__(:remove_const, :FalseClass)
                            GC.start
                            false.inspect)
assert_equal &#39;nil&#39;,     %q( Object.__send__(:remove_const, :NilClass)
                            GC.start
                            nil.inspect)


# inherited class
assert_equal &#39;true&#39;,    %q( class A; end
                            class C &lt; A; end
                            Object.const_defined?(:C) )
assert_equal &#39;Class&#39;,   %q( class A; end
                            class C &lt; A; end
                            C.class )
assert_equal &#39;C&#39;,       %q( class A; end
                            class C &lt; A; end
                            C.name )
assert_equal &#39;C&#39;,       %q( class A; end
                            class C &lt; A; end
                            C.new.class )
assert_equal &#39;C&#39;,       %q( class A; end
                            class C &lt; A; end
                            C.new.class.name )
assert_equal &#39;Class&#39;,   %q( class A; end
                            class C &lt; A; end
                            C.new.class.class )

# module
assert_equal &#39;true&#39;,    %q( module M; end
                            Object.const_defined?(:M) )
assert_equal &#39;Module&#39;,  %q( module M; end
                            M.class )
assert_equal &#39;M&#39;,       %q( module M; end
                            M.name )
assert_equal &#39;C&#39;,       %q( module M; end
                            class C; include M; end
                            C.new.class )

# nested class
assert_equal &#39;A::B&#39;,    %q( class A; end
                            class A::B; end
                            A::B )
assert_equal &#39;A::B&#39;,    %q( class A; end
                            class A::B; end
                            A::B.name )
assert_equal &#39;A::B&#39;,    %q( class A; end
                            class A::B; end
                            A::B.new.class )
assert_equal &#39;Class&#39;,   %q( class A; end
                            class A::B; end
                            A::B.new.class.class )
assert_equal &#39;A::B::C&#39;, %q( class A; end
                            class A::B; end
                            class A::B::C; end
                            A::B::C )
assert_equal &#39;A::B::C&#39;, %q( class A; end
                            class A::B; end
                            class A::B::C; end
                            A::B::C.name )
assert_equal &#39;Class&#39;,   %q( class A; end
                            class A::B; end
                            class A::B::C; end
                            A::B::C.class )
assert_equal &#39;A::B::C&#39;, %q( class A; end
                            class A::B; end
                            class A::B::C; end
                            A::B::C.new.class )
assert_equal &#39;Class&#39;,   %q( class A; end
                            class A::B; end
                            class A::B::C; end
                            A::B::C.new.class.class )
assert_equal &#39;A::B2&#39;,   %q( class A; end
                            class A::B; end
                            class A::B2 &lt; A::B; end
                            A::B2 )
assert_equal &#39;Class&#39;,   %q( class A; end
                            class A::B; end
                            class A::B2 &lt; A::B; end
                            A::B2.class )

# reopen
assert_equal &#39;true&#39;,    %q( class C; end;  c1 = ::C
                            class C; end;  c2 = ::C
                            c1.equal?(c2) )
assert_equal &#39;1&#39;,       %q( class C; end
                            class A; end
                            begin class C &lt; A; end; rescue TypeError; 1 end )
assert_equal &#39;1&#39;,       %q( class C; end
                            begin module C; end; rescue TypeError; 1 end )
assert_equal &#39;1&#39;,       %q( C = 1   # [yarv-dev:782]
                            begin class C; end; rescue TypeError; 1 end )
assert_equal &#39;1&#39;,       %q( C = 1   # [yarv-dev:800]
                            begin module C; end; rescue TypeError; 1 end )

# colon2, colon3
assert_equal &#39;1&#39;,       %q( class A; end;  A::C = 1;  A::C )
assert_equal &#39;1&#39;,       %q( A = 7;  begin A::C = 7; rescue TypeError; 1 end )
assert_equal &#39;1&#39;,       %q( begin 7::C = 7; rescue TypeError; 1 end )
assert_equal &#39;C&#39;,       %q( class A; class ::C; end end;  C )
assert_equal &#39;Class&#39;,   %q( class A; class ::C; end end;  C.class )
assert_equal &#39;OK&#39;,      %q( class A; ::C = &quot;OK&quot;; end;  C )
assert_equal &#39;String&#39;,  %q( class A; ::C = &quot;OK&quot;; end;  C.class )

# class/module dup
assert_equal &#39;Class&#39;,   %q( class C; end;  C.dup.class )
assert_equal &#39;Module&#39;,  %q( module M; end;  M.dup.class )


assert_equal &quot;ok&quot;, %q{
  module Foo
  end

  begin
    def foo(&amp;b)
      Foo.module_eval &amp;b
    end
    foo{
      def bar
      end
    }
    bar()
  rescue NameError
    :ok
  end
}, &#39;[ruby-core:14378]&#39;

assert_equal &#39;3&#39;, %q{
  $i = 0
  class C
    def self.const_missing *args
      $i+=1
    end
  end

  3.times{
    C::FOO
  }
  $i
}

assert_match /::C\z/, %q{
  c = nil
  Module.new{|m| c = class m::C; name; end}
  c
}, &#39;[ruby-dev:38456]&#39;

assert_normal_exit %q{
  s = Symbol.dup
  class &lt;&lt; s
  end
  s.allocate.to_s
}, &#39;[ruby-core:30843]&#39;
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_proc.out</h2>
      <pre style='float: left; width: 50%'>assert_equal %q{[1, 2, 3]}, %q{
  def getproc &amp;b
    b
  end

  def m
    yield
  end

  m{
    i = 1
    m{
      j = 2
      m{
        k = 3
        getproc{
          [i, j, k]
        }
      }
    }
  }.call
}
assert_equal %q{7}, %q{
  def make_proc(&amp;b)
    b
  end

  def make_closure
    a = 0
    make_proc{
      a+=1
    }
  end

  cl = make_closure
  cl.call + cl.call * cl.call
}
assert_equal %q{ok}, %q{
  class C
    def foo
      :ok
    end
  end

  def block
    C.method(:new).to_proc
  end
  b = block()
  b.call.foo
}
assert_equal %q{[0, 1, :last, 0, 2, :last]}, %q{
  def proc &amp;b
    b
  end

  pr = []
  proc{|i_b|
    p3 = proc{|j_b|
      pr &lt;&lt; proc{|k_b|
        [i_b, j_b, k_b]
      }
    }
    p3.call(1)
    p3.call(2)
  }.call(0)

  pr[0].call(:last).concat pr[1].call(:last)
}
assert_equal %q{12}, %q{
  def iter
    yield
  end

  def getproc &amp;b
    b
  end

  iter{
    bvar = 3
    getproc{
      bvar2 = 4
      bvar * bvar2
    }
  }.call
}
assert_equal %q{200}, %q{
  def iter
    yield
  end

  def getproc &amp;b
    b
  end

  loc1 = 0
  pr1 = iter{
    bl1 = 1
    getproc{
      loc1 += 1
      bl1  += 1
      loc1 + bl1
    }
  }

  pr2 = iter{
    bl1 = 1
    getproc{
      loc1 += 1
      bl1  += 1
      loc1 + bl1
    }
  }

  pr1.call; pr2.call
  pr1.call; pr2.call
  pr1.call; pr2.call
  (pr1.call + pr2.call) * loc1
}
assert_equal %q{[1, 2]}, %q{
  def proc(&amp;pr)
    pr
  end

  def m
    a = 1
    m2{
      a
    }
  end

  def m2
    b = 2
    proc{
      [yield, b]
    }
  end

  pr = m
  x = [&#39;a&#39;, 1,2,3,4,5,6,7,8,9,0,
            1,2,3,4,5,6,7,8,9,0,
            1,2,3,4,5,6,7,8,9,0,
            1,2,3,4,5,6,7,8,9,0,
            1,2,3,4,5,6,7,8,9,0,]
  pr.call
}
assert_equal %q{1}, %q{
  def proc(&amp;pr)
    pr
  end

  def m
    a = 1
    m2{
      a
    }
  end

  def m2
    b = 2
    proc{
      [yield, b]
    }
    100000.times{|x|
      &quot;#{x}&quot;
    }
    yield
  end
  m
}
assert_equal %q{[:C, :C]}, %q{
  Const = :top
  class C
    Const = :C
    $pr = proc{
      (1..2).map{
        Const
      }
    }
  end
  $pr.call
}
assert_equal %q{top}, %q{
  Const = :top
  class C
    Const = :C
  end
  pr = proc{
    Const
  }
  C.class_eval %q{
    pr.call
  }
}
assert_equal %q{1}, %q{
  def m(&amp;b)
    b
  end

  m{|e_proctest| e_proctest}.call(1)
}
assert_equal %q{12}, %q{
  def m(&amp;b)
    b
  end

  m{|e_proctest1, e_proctest2|
    a = e_proctest1 * e_proctest2 * 2
    a * 3
  }.call(1, 2)
}
assert_equal %q{[[], [1], [1, 2], [1, 2, 3]]}, %q{
  [
  Proc.new{|*args| args}.call(),
  Proc.new{|*args| args}.call(1),
  Proc.new{|*args| args}.call(1, 2),
  Proc.new{|*args| args}.call(1, 2, 3),
  ]
}
assert_equal %q{[[nil, []], [1, []], [1, [2]], [1, [2, 3]]]}, %q{
  [
  Proc.new{|a, *b| [a, b]}.call(),
  Proc.new{|a, *b| [a, b]}.call(1),
  Proc.new{|a, *b| [a, b]}.call(1, 2),
  Proc.new{|a, *b| [a, b]}.call(1, 2, 3),
  ]
}
assert_equal %q{0}, %q{
  pr = proc{
    $SAFE
  }
  $SAFE = 1
  pr.call
}
assert_equal %q{[1, 0]}, %q{
  pr = proc{
    $SAFE += 1
  }
  [pr.call, $SAFE]
}
assert_equal %q{1}, %q{
  def m(&amp;b)
    b
  end
  m{1}.call
}
assert_equal %q{3}, %q{
  def m(&amp;b)
    b
  end

  m{
    a = 1
    a + 2
  }.call
}
assert_equal %Q{ok\n}, %q{
  class A; def get_block; proc {puts &quot;ok&quot;} end end
  block = A.new.get_block
  GC.start
  block.call
}, &#39;[ruby-core:14885]&#39;

assert_equal &#39;ok&#39;, %q{
  a = lambda {|x, y, &amp;b| b }
  b = a.curry[1]
  if b.call(2){} == nil
    :ng
  else
    :ok
  end
}, &#39;[ruby-core:15551]&#39;

assert_equal &#39;ok&#39;, %q{
  lambda {
    break :ok
    :ng
  }.call
}, &#39;[ruby-dev:34646]&#39;

assert_equal %q{[:bar, :foo]}, %q{
  def foo
    klass = Class.new do
      define_method(:bar) do
        return :bar
      end
    end
    [klass.new.bar, :foo]
  end
  foo
}, &quot;[ ruby-Bugs-19304 ]&quot;

assert_equal &#39;ok&#39;, %q{
   $x = :ok
   def def7(x, y)
      x[y]
      $x = :ng
   end
   def test_def7
      def7(lambda {|x| x.call}, Proc.new {return})
      $x = :ng
   end
   test_def7
   $x
}, &#39;[ruby-core:17164]&#39;

assert_equal &#39;ok&#39;, %q{
  lambda { a = lambda { return }; $x = :ng; a[]; $x = :ok }.call
  $x
}, &#39;[ruby-core:17164]&#39;

assert_equal &#39;ok&#39;, %q{
  lambda { a = lambda { break }; $x = :ng; a[]; $x = :ok }.call
  $x
}, &#39;[ruby-core:17164]&#39;

assert_equal &#39;ok&#39;, %q{
  def def8
    $x = :ng
    lambda { a = Proc.new { return }; a[]}.call
    $x = :ok
  end
  def8
  $x
}, &#39;[ruby-core:17164]&#39;


assert_equal &#39;ok&#39;, %q{
   def def9
      lambda {|a| $x = :ok; a[]; $x = :ng }.call(Proc.new { return })
      $x = :ng
   end
   def9
   $x
}, &#39;[ruby-core:17164]&#39;

assert_equal &#39;ok&#39;, %q{
   def def10
     $x = :ng
     lambda { 1.times { return } }.call
     $x = :ok
   end
   $x = :ok
   def10
   $x
}, &#39;[ruby-core:17164]&#39;

assert_equal &#39;ok&#39;, %q{
   def def11
      yield
   end
   begin
      lambda { def11 { return } }.call
   rescue LocalJumpError
      :ng
   else
      :ok
   end
}, &#39;[ruby-core:17164]&#39;

assert_equal &#39;ok&#39;, %q{
   def def12
      b = Proc.new { $x = :ng; lambda { return }.call; $x = :ok }.call
   end
   def12
   $x
}, &#39;[ruby-core:17164]&#39;

assert_equal &#39;ok&#39;, %q{
  def m
    pr = proc{
      proc{
        return :ok
      }
    }.call
    pr.call
    :ng
  end
  m()
}

assert_equal &#39;ok&#39;, %q{
  class Foo
    def call_it
      p = Proc.new
      p.call
    end
  end

  def give_it
    proc { :ok }
  end

  f = Foo.new
  a_proc = give_it
  f.call_it(&amp;give_it())
}, &#39;[ruby-core:15711]&#39;

assert_equal &#39;foo!&#39;, %q{
  class FooProc &lt; Proc
    def initialize
      @foo = &quot;foo!&quot;
    end

    def bar
      @foo
    end
  end

  def bar
    FooProc.new &amp;lambda{
      p 1
    }
  end

  fp = bar(&amp;lambda{
    p 2
  })

  fp.bar
}, &#39;Subclass of Proc&#39;

assert_equal &#39;ok&#39;, %q{
  o = Object.new
  def o.write(s); end
  $stderr = o
  at_exit{
    print $!.message
  }
  raise &quot;ok&quot;
}

assert_equal &#39;ok&#39;, %q{
  lambda do
    class A
      class B
        proc{return :ng}.call
      end
    end
  end.call
  :ok
}

assert_equal &#39;ok&#39;, %q{
  $proc = proc{return}
  begin
    lambda do
      class A
        class B
          $proc.call
        end
      end
    end.call
    :ng
  rescue LocalJumpError
    :ok
  end
}

assert_equal &#39;ok&#39;, %q{
  def x
    binding
  end
  b = x{|a| a }
  b.eval(&#39;yield(&quot;ok&quot;)&#39;)
}, &#39;[Bug #5634]&#39;

assert_equal &#39;ok&#39;, %q{
  def x
    binding
  end
  eval(&quot;x { &#39;ok&#39; }&quot;).eval &quot;yield&quot;
}, &#39;[Bug #5634]&#39;

assert_equal &#39;ok&#39;, %q{
  def x
    binding
  end
  def m
    x{ &#39;ok&#39; }
  end
  eval(&#39;yield&#39;, m)
}, &#39;[Bug #5634]&#39;

</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_block.out</h2>
      <pre style='float: left; width: 50%'>assert_equal %q{1}, %q{
  1.times{
    begin
      a = 1
    ensure
      foo = nil
    end
  }
}
assert_equal %q{2}, %q{
  [1,2,3].find{|x| x == 2}
}
assert_equal %q{2}, %q{
  class E
    include Enumerable
    def each(&amp;block)
      [1, 2, 3].each(&amp;block)
    end
  end
  E.new.find {|x| x == 2 }
}
assert_equal %q{6}, %q{
  sum = 0
  for x in [1, 2, 3]
    sum += x
  end
  sum
}
assert_equal %q{15}, %q{
  sum = 0
  for x in (1..5)
    sum += x
  end
  sum
}
assert_equal %q{0}, %q{
  sum = 0
  for x in []
    sum += x
  end
  sum
}
assert_equal %q{1}, %q{
  ans = []
  1.times{
    for n in 1..3
      a = n
      ans &lt;&lt; a
    end
  }
}
assert_equal %q{1..3}, %q{
  ans = []
  for m in 1..3
    for n in 1..3
      a = [m, n]
      ans &lt;&lt; a
    end
  end
}
assert_equal %q{[1, 2, 3]}, %q{
  (1..3).to_a
}
assert_equal %q{[4, 8, 12]}, %q{
  (1..3).map{|e|
    e * 4
  }
}
assert_equal %q{[1, 2, 3]}, %q{
  class C
    include Enumerable
    def each
      [1,2,3].each{|e|
        yield e
      }
    end
  end

  C.new.to_a
}
assert_equal %q{[4, 5, 6]}, %q{
  class C
    include Enumerable
    def each
      [1,2,3].each{|e|
        yield e
      }
    end
  end

  C.new.map{|e|
    e + 3
  }
}
assert_equal %q{100}, %q{
  def m
    yield
  end
  def n
    yield
  end

  m{
    n{
      100
    }
  }
}
assert_equal %q{20}, %q{
  def m
    yield 1
  end

  m{|ib|
    m{|jb|
      i = 20
    }
  }
}
assert_equal %q{2}, %q{
  def m
    yield 1
  end

  m{|ib|
    m{|jb|
      ib = 20
      kb = 2
    }
  }
}
assert_equal %q{3}, %q{
  def iter1
    iter2{
      yield
    }
  end

  def iter2
    yield
  end

  iter1{
    jb = 2
    iter1{
      jb = 3
    }
    jb
  }
}
assert_equal %q{2}, %q{
  def iter1
    iter2{
      yield
    }
  end

  def iter2
    yield
  end

  iter1{
    jb = 2
    iter1{
      jb
    }
    jb
  }
}
assert_equal %q{2}, %q{
  def m
    yield 1
  end
  m{|ib|
    ib*2
  }
}
assert_equal %q{92580}, %q{
  def m
    yield 12345, 67890
  end
  m{|ib,jb|
    ib*2+jb
  }
}
assert_equal %q{[10, nil]}, %q{
  def iter
    yield 10
  end

  a = nil
  [iter{|a|
    a
  }, a]
}
assert_equal %q{21}, %q{
  def iter
    yield 10
  end

  iter{|a|
    iter{|a|
      a + 1
    } + a
  }
}
assert_equal %q{[10, 20, 30, 40, nil, nil, nil, nil]}, %q{
  def iter
    yield 10, 20, 30, 40
  end

  a = b = c = d = nil
  iter{|a, b, c, d|
    [a, b, c, d]
  } + [a, b, c, d]
}
assert_equal %q{[10, 20, 30, 40, nil, nil]}, %q{
  def iter
    yield 10, 20, 30, 40
  end

  a = b = nil
  iter{|a, b, c, d|
    [a, b, c, d]
  } + [a, b]
}
assert_equal %q{[1]}, %q{
  $a = []

  def iter
    yield 1
  end

  def m
    x = iter{|x|
      $a &lt;&lt; x
      y = 0
    }
  end
  m
  $a
}
assert_equal %q{[1, [2]]}, %q{
  def iter
    yield 1, 2
  end

  iter{|a, *b|
    [a, b]
  }
}
assert_equal %q{[[1, 2]]}, %q{
  def iter
    yield 1, 2
  end

  iter{|*a|
    [a]
  }
}
assert_equal %q{[1, 2, []]}, %q{
  def iter
    yield 1, 2
  end

  iter{|a, b, *c|
    [a, b, c]
  }
}
assert_equal %q{[1, 2, nil, []]}, %q{
  def iter
    yield 1, 2
  end

  iter{|a, b, c, *d|
    [a, b, c, d]
  }
}
assert_equal %q{1}, %q{
  def m
    yield
  end
  m{
    1
  }
}
assert_equal %q{15129}, %q{
  def m
    yield 123
  end
  m{|ib|
    m{|jb|
      ib*jb
    }
  }
}
assert_equal %q{2}, %q{
  def m a
    yield a
  end
  m(1){|ib|
    m(2){|jb|
      ib*jb
    }
  }
}
assert_equal %q{9}, %q{
  sum = 0
  3.times{|ib|
    2.times{|jb|
      sum += ib + jb
    }}
  sum
}
assert_equal %q{10}, %q{
  3.times{|bl|
    break 10
  }
}
assert_equal %q{[1, 2]}, %q{
  def iter
    yield 1,2,3
  end

  iter{|i, j|
    [i, j]
  }
}
assert_equal %q{[1, nil]}, %q{
  def iter
    yield 1
  end

  iter{|i, j|
    [i, j]
  }
}

assert_equal &#39;0&#39;, %q{
def m()
end
m {|(v0,*,(*)),|}
m {|(*v0,(*)),|}
m {|(v0,*v1,(*)),|}
m {|((v0,*v1,v2)),|}
m {|(v0,*v1,v2),|}
m {|(v0,*v1,(v2)),|}
m {|((*),*v0,v1),|}
m {|((v0),*v1,v2),|}
m {|(v0,v1,*v2,v3),|}
m {|v0,(v1,*v2,v3),|}
m {|(v0,*v1,v2),v3,|}
m {|(v0,*v1,v2)|}
m {|(v0,*v1,v2),&amp;v3|}
m {|(v0,*v1,v2),*|}
m {|(v0,*v1,v2),*,&amp;v3|}
m {|*,(v0,*v1,v2)|}
m {|*,(v0,*v1,v2),&amp;v3|}
m {|v0,*,(v1,*v2,v3)|}
m {|v0,*,(v1,*v2,v3),&amp;v4|}
m {|(v0,*v1,v2),*,v3|}
m {|(v0,*v1,v2),*,v3,&amp;v4|}
m {|(v0, *v1, v2)|}
m {|(*,v)|}
0
}, &quot;block parameter (shouldn&#39;t SEGV: [ruby-dev:31143])&quot;

assert_equal &#39;nil&#39;, %q{
  def m
    yield
  end
  m{|&amp;b| b}.inspect
}, &#39;[ruby-dev:31147]&#39;

assert_equal &#39;nil&#39;, %q{
  def m()
    yield
  end
  m {|(v,(*))|}.inspect
}, &#39;[ruby-dev:31160]&#39;

assert_equal &#39;nil&#39;, %q{
  def m()
    yield
  end
  m {|(*,a,b)|}.inspect
}, &#39;[ruby-dev:31153]&#39;

assert_equal &#39;nil&#39;, %q{
  def m()
    yield
  end
  m {|((*))|}.inspect
}

assert_equal %q{[1, 1, [1, nil], [1, nil], [1, nil], [1, nil], [1, 1], 1, [1, nil], [1, nil], [1, nil], [1, nil], [[1, 1], [1, 1]], [1, 1], [1, 1], [1, 1], [1, nil], [1, nil], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[1, 1], [1, 1]], [[1, 1], [1, 1]], [[1, 1], [1, 1]], [1, 1], [1, 1], [[[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[1, 1], [1, 1]], [[1, 1], [1, 1]]]}, %q{
def m(ary = [])
  yield(ary)
end

$ans = []
o = 1
5.times{
  v,(*) = o; $ans &lt;&lt; o
  m(o){|(v,(*))| $ans &lt;&lt; v}
  ((x, y)) = o; $ans &lt;&lt; [x, y]
  m(o){|((x, y))| $ans &lt;&lt; [x, y]}
  (((x, y))) = o; $ans &lt;&lt; [x, y]
  m(o){|(((x, y)))| $ans &lt;&lt; [x, y]}
  o = [o, o]
}; $ans
}

assert_equal &#39;0&#39;, %q{
  def m()
    yield [0]
  end
  m {|*,v| v}.inspect
}, &#39;[ruby-dev:31437]&#39;
assert_equal &#39;[0]&#39;, %q{
  def m
    yield [0]
  end
  m{|v, &amp;b| v}.inspect
}, &#39;[ruby-dev:31440]&#39;
assert_equal &#39;ok&#39;, %q{
  begin
    lambda{|a|}.call(1, 2)
  rescue ArgumentError
    :ok
  else
    :ng
  end
}, &#39;[ruby-dev:31464]&#39;
assert_equal &#39;ok&#39;, %q{
  begin
    lambda{|&amp;b|}.call(3)
  rescue ArgumentError
    :ok
  else
    :ng
  end
}, &#39;[ruby-dev:31472]&#39;
assert_equal &#39;ok&#39;, %q{
  class C
    def each
      yield [1,2]
      yield 1,2
    end
  end
  vs1 = []
  C.new.each {|*v| vs1 &lt;&lt; v }
  vs2 = []
  C.new.to_enum.each {|*v| vs2 &lt;&lt; v }
  vs1 == vs2 ? :ok : :ng
}, &#39;[ruby-dev:32329]&#39;

assert_normal_exit %q{
  e = [1,2,3].each
  10000.times {
    e = [e].each
  }
  Thread.new { GC.start }.join
}, &#39;[ruby-dev:32604]&#39;


assert_equal &#39;[nil, []]&#39;, %q{
  def m() yield nil,[] end
  l = lambda {|*v| v}
  GC.stress=true
  r = m(&amp;l)
  GC.stress=false
  r.inspect
}, &#39;[ruby-dev:32567]&#39;

assert_equal NilClass.to_s, %q{
  r = false; 1.times{|&amp;b| r = b}; r.class
}

assert_equal &#39;ok&#39;, %q{
  class C
    define_method(:foo) do |arg, &amp;block|
      if block then block.call else arg end
    end
  end
  C.new.foo(&quot;ng&quot;) {&quot;ok&quot;}
}, &#39;[ruby-talk:266422]&#39;

assert_equal &#39;ok&#39;, %q{
  class C
    define_method(:xyz) do |o, k, &amp;block|
      block.call(o, k)
    end
  end
  C.new.xyz(&quot;o&quot;,&quot;k&quot;) {|o, k| o+k}
}, &#39;[ruby-core:20544]&#39;

assert_equal &#39;ok&#39;, %q{
  class C
    define_method(:xyz) do |*args, &amp;block|
      block.call(*args)
    end
  end
  C.new.xyz(&quot;o&quot;,&quot;k&quot;) {|*args| args.join(&quot;&quot;)}
}, &#39;[ruby-core:20544]&#39;

assert_equal &#39;ok&#39;, %q{
  STDERR.reopen(STDOUT)
  class C
    define_method(:foo) do |&amp;block|
      block.call if block
    end
    result = &quot;ng&quot;
    new.foo() {result = &quot;ok&quot;}
    result
  end
}

assert_equal &quot;ok&quot;, %q{
  class Bar
    def bar; :ok; end
  end
  def foo
    yield(Bar.new) if block_given?
  end
  foo(&amp;:bar)
}, &#39;[ruby-core:14279]&#39;

assert_normal_exit %q{
  class Controller
    def respond_to(&amp;block)
      responder = Responder.new
      block.call(responder)
      responder.respond
    end
    def test_for_bug
      respond_to{|format|
        format.js{
          puts &quot;in test&quot;
          render{|obj|
            puts obj
          }
        }
      }
    end
    def render(&amp;block)
      puts &quot;in render&quot;
    end
  end

  class Responder
    def method_missing(symbol, &amp;block)
      puts &quot;enter method_missing&quot;
      @response = Proc.new{
        puts &#39;in method missing&#39;
        block.call
      }
      puts &quot;leave method_missing&quot;
    end
    def respond
      @response.call
    end
  end
  t = Controller.new
  t.test_for_bug
}, &#39;[ruby-core:14395]&#39;

assert_equal &#39;true&#39;, %q{
  class C0
    def foo
      block_given?
    end
  end

  class C1 &lt; C0
    def foo
      super
    end
  end

  C1.new.foo{}
}

assert_equal &#39;true&#39;, %q{
  class C0
    def foo
      block_given?
    end
  end

  class C1 &lt; C0
    def foo
      super()
    end
  end

  C1.new.foo{}
}

assert_equal &#39;ok&#39;, %q{
  1.times do
    begin
      raise
    rescue
      begin
        raise
      rescue
        break
      end
    end
  end
  &#39;ok&#39;
}
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_literal.out</h2>
      <pre style='float: left; width: 50%'># empty program
assert_equal &#39;&#39;,                &#39;&#39;
assert_equal &#39;&#39;,                &#39; &#39;
assert_equal &#39;&#39;,                &quot;\n&quot;

# special const
assert_equal &#39;true&#39;,            &#39;true&#39;
assert_equal &#39;TrueClass&#39;,       &#39;true.class&#39;
assert_equal &#39;false&#39;,           &#39;false&#39;
assert_equal &#39;FalseClass&#39;,      &#39;false.class&#39;
assert_equal &#39;&#39;,                &#39;nil&#39;
assert_equal &#39;nil&#39;,             &#39;nil.inspect&#39;
assert_equal &#39;NilClass&#39;,        &#39;nil.class&#39;
assert_equal &#39;sym&#39;,             &#39;:sym&#39;
assert_equal &#39;:sym&#39;,            &#39;:sym.inspect&#39;
assert_equal &#39;Symbol&#39;,          &#39;:sym.class&#39;
assert_equal &#39;1234&#39;,            &#39;1234&#39;
assert_equal &#39;Integer&#39;,         &#39;1234.class&#39;
assert_equal &#39;1234&#39;,            &#39;1_2_3_4&#39;
assert_equal &#39;Integer&#39;,         &#39;1_2_3_4.class&#39;
assert_equal &#39;18&#39;,              &#39;0x12&#39;
assert_equal &#39;Integer&#39;,         &#39;0x12.class&#39;
assert_equal &#39;15&#39;,              &#39;0o17&#39;
assert_equal &#39;Integer&#39;,         &#39;0o17.class&#39;
assert_equal &#39;5&#39;,               &#39;0b101&#39;
assert_equal &#39;Integer&#39;,         &#39;0b101.class&#39;
assert_equal &#39;123456789012345678901234567890&#39;, &#39;123456789012345678901234567890&#39;
assert_equal &#39;Integer&#39;,         &#39;123456789012345678901234567890.class&#39;
assert_equal &#39;2.0&#39;,             &#39;2.0&#39;
assert_equal &#39;Float&#39;,           &#39;1.3.class&#39;

# self
assert_equal &#39;main&#39;,            &#39;self&#39;
assert_equal &#39;Object&#39;,          &#39;self.class&#39;

# string literal
assert_equal &#39;a&#39;,               &#39;?a&#39;
assert_equal &#39;String&#39;,          &#39;?a.class&#39;
assert_equal &#39;A&#39;,               &#39;?A&#39;
assert_equal &#39;String&#39;,          &#39;?A.class&#39;
assert_equal &quot;\n&quot;,              &#39;?\n&#39;
assert_equal &#39;String&#39;,          &#39;?\n.class&#39;
assert_equal &#39; &#39;,               &#39;?\ &#39;
assert_equal &#39;String&#39;,          &#39;?\ .class&#39;
assert_equal &#39;string&#39;,          &quot;&#39;string&#39;&quot;
assert_equal &#39;string&#39;,          &#39;&quot;string&quot;&#39;
assert_equal &#39;string&#39;,          &#39;%(string)&#39;
assert_equal &#39;string&#39;,          &#39;%q(string)&#39;
assert_equal &#39;string&#39;,          &#39;%Q(string)&#39;
assert_equal &#39;string string&#39;,   &#39;&quot;string string&quot;&#39;
assert_equal &#39; &#39;,               &#39;&quot; &quot;&#39;
assert_equal &quot;\0&quot;,              &#39;&quot;\0&quot;&#39;
assert_equal &quot;\1&quot;,              &#39;&quot;\1&quot;&#39;
assert_equal &quot;3&quot;,               &#39;&quot;\x33&quot;&#39;
assert_equal &quot;\n&quot;,              &#39;&quot;\n&quot;&#39;

# dynamic string literal
assert_equal &#39;2&#39;,               &#39;&quot;#{1 + 1}&quot;&#39;
assert_equal &#39;16&#39;,              &#39;&quot;#{2 ** 4}&quot;&#39;
assert_equal &#39;string&#39;,          &#39;s = &quot;string&quot;; &quot;#{s}&quot;&#39;

# dynamic symbol literal
assert_equal &#39;a3c&#39;,             &#39;:&quot;a#{1+2}c&quot;&#39;
assert_equal &#39;:a3c&#39;,            &#39;:&quot;a#{1+2}c&quot;.inspect&#39;
assert_equal &#39;Symbol&#39;,          &#39;:&quot;a#{1+2}c&quot;.class&#39;

# xstring
unless nacl?
  assert_equal &quot;foo\n&quot;,           %q(`echo foo`)
  assert_equal &quot;foo\n&quot;,           %q(s = &quot;foo&quot;; `echo #{s}`)
end

# regexp
assert_equal &#39;&#39;,                &#39;//.source&#39;
assert_equal &#39;Regexp&#39;,          &#39;//.class&#39;
assert_equal &#39;0&#39;,               &#39;// =~ &quot;a&quot;&#39;
assert_equal &#39;0&#39;,               &#39;// =~ &quot;&quot;&#39;
assert_equal &#39;a&#39;,               &#39;/a/.source&#39;
assert_equal &#39;Regexp&#39;,          &#39;/a/.class&#39;
assert_equal &#39;0&#39;,               &#39;/a/ =~ &quot;a&quot;&#39;
assert_equal &#39;0&#39;,               &#39;/test/ =~ &quot;test&quot;&#39;
assert_equal &#39;&#39;,                &#39;/test/ =~ &quot;tes&quot;&#39;
assert_equal &#39;0&#39;,               &#39;re = /test/; re =~ &quot;test&quot;&#39;
assert_equal &#39;0&#39;,               &#39;str = &quot;test&quot;; /test/ =~ str&#39;
assert_equal &#39;0&#39;,               &#39;re = /test/; str = &quot;test&quot;; re =~ str&#39;

# dynamic regexp
assert_equal &#39;regexp&#39;,          %q(/re#{&#39;ge&#39;}xp/.source)
assert_equal &#39;Regexp&#39;,          %q(/re#{&#39;ge&#39;}xp/.class)

# array
assert_equal &#39;Array&#39;,           &#39;[].class&#39;
assert_equal &#39;0&#39;,               &#39;[].size&#39;
assert_equal &#39;0&#39;,               &#39;[].length&#39;
assert_equal &#39;[]&#39;,              &#39;[].inspect&#39;
assert_equal &#39;Array&#39;,           &#39;[0].class&#39;
assert_equal &#39;1&#39;,               &#39;[3].size&#39;
assert_equal &#39;[3]&#39;,             &#39;[3].inspect&#39;
assert_equal &#39;3&#39;,               &#39;a = [3]; a[0]&#39;
assert_equal &#39;Array&#39;,           &#39;[1,2].class&#39;
assert_equal &#39;2&#39;,               &#39;[1,2].size&#39;
assert_equal &#39;[1, 2]&#39;,          &#39;[1,2].inspect&#39;
assert_equal &#39;Array&#39;,           &#39;[1,2,3,4,5].class&#39;
assert_equal &#39;5&#39;,               &#39;[1,2,3,4,5].size&#39;
assert_equal &#39;[1, 2, 3, 4, 5]&#39;, &#39;[1,2,3,4,5].inspect&#39;
assert_equal &#39;1&#39;,               &#39;a = [1,2]; a[0]&#39;
assert_equal &#39;2&#39;,               &#39;a = [1,2]; a[1]&#39;
assert_equal &#39;Array&#39;,           &#39;a = [1 + 2, 3 + 4, 5 + 6]; a.class&#39;
assert_equal &#39;[3, 7, 11]&#39;,      &#39;a = [1 + 2, 3 + 4, 5 + 6]; a.inspect&#39;
assert_equal &#39;7&#39;,               &#39;a = [1 + 2, 3 + 4, 5 + 6]; a[1]&#39;
assert_equal &#39;1&#39;,               &#39;([0][0] += 1)&#39;
assert_equal &#39;1&#39;,               &#39;([2][0] -= 1)&#39;
assert_equal &#39;Array&#39;,           &#39;a = [obj = Object.new]; a.class&#39;
assert_equal &#39;1&#39;,               &#39;a = [obj = Object.new]; a.size&#39;
assert_equal &#39;true&#39;,            &#39;a = [obj = Object.new]; a[0] == obj&#39;
assert_equal &#39;5&#39;,               &#39;a = [1,2,3]; a[1] = 5; a[1]&#39;
assert_equal &#39;bar&#39;,             &#39;[*:foo];:bar&#39;
assert_equal &#39;[1, 2]&#39;,          &#39;def nil.to_a; [2]; end; [1, *nil]&#39;
assert_equal &#39;[1, 2]&#39;,          &#39;def nil.to_a; [1, 2]; end; [*nil]&#39;
assert_equal &#39;[0, 1, {2=&gt;3}]&#39;,  &#39;[0, *[1], 2=&gt;3]&#39;, &quot;[ruby-dev:31592]&quot;


# hash
assert_equal &#39;Hash&#39;,            &#39;{}.class&#39;
assert_equal &#39;{}&#39;,              &#39;{}.inspect&#39;
assert_equal &#39;Hash&#39;,            &#39;{1=&gt;2}.class&#39;
assert_equal &#39;{1=&gt;2}&#39;,          &#39;{1=&gt;2}.inspect&#39;
assert_equal &#39;2&#39;,               &#39;h = {1 =&gt; 2}; h[1]&#39;
assert_equal &#39;0&#39;,               &#39;h = {1 =&gt; 2}; h.delete(1); h.size&#39;
assert_equal &#39;&#39;,                &#39;h = {1 =&gt; 2}; h.delete(1); h[1]&#39;
assert_equal &#39;2&#39;,               &#39;h = {&quot;string&quot; =&gt; &quot;literal&quot;, &quot;goto&quot; =&gt; &quot;hell&quot;}; h.size&#39;
assert_equal &#39;literal&#39;, &#39;h = {&quot;string&quot;=&gt;&quot;literal&quot;, &quot;goto&quot;=&gt;&quot;hell&quot;}; h[&quot;string&quot;]&#39;
assert_equal &#39;hell&#39;, &#39;h = {&quot;string&quot;=&gt;&quot;literal&quot;, &quot;goto&quot;=&gt;&quot;hell&quot;}; h[&quot;goto&quot;]&#39;

# range
assert_equal &#39;Range&#39;,           &#39;(1..2).class&#39;
assert_equal &#39;1..2&#39;,            &#39;(1..2).inspect&#39;
assert_equal &#39;1&#39;,               &#39;(1..2).begin&#39;
assert_equal &#39;2&#39;,               &#39;(1..2).end&#39;
assert_equal &#39;false&#39;,           &#39;(1..2).exclude_end?&#39;
assert_equal &#39;Range&#39;,           &#39;r = 1..2; r.class&#39;
assert_equal &#39;1..2&#39;,            &#39;r = 1..2; r.inspect&#39;
assert_equal &#39;1&#39;,               &#39;r = 1..2; r.begin&#39;
assert_equal &#39;2&#39;,               &#39;r = 1..2; r.end&#39;
assert_equal &#39;false&#39;,           &#39;r = 1..2; r.exclude_end?&#39;
assert_equal &#39;Range&#39;,           &#39;(1...3).class&#39;
assert_equal &#39;1...3&#39;,           &#39;(1...3).inspect&#39;
assert_equal &#39;1&#39;,               &#39;(1...3).begin&#39;
assert_equal &#39;3&#39;,               &#39;(1...3).end&#39;
assert_equal &#39;true&#39;,            &#39;(1...3).exclude_end?&#39;
assert_equal &#39;Range&#39;,           &#39;r = (1...3); r.class&#39;
assert_equal &#39;1...3&#39;,           &#39;r = (1...3); r.inspect&#39;
assert_equal &#39;1&#39;,               &#39;r = (1...3); r.begin&#39;
assert_equal &#39;3&#39;,               &#39;r = (1...3); r.end&#39;
assert_equal &#39;true&#39;,            &#39;r = (1...3); r.exclude_end?&#39;
assert_equal &#39;Range&#39;,           &#39;r = (1+2 .. 3+4); r.class&#39;
assert_equal &#39;3..7&#39;,            &#39;r = (1+2 .. 3+4); r.inspect&#39;
assert_equal &#39;3&#39;,               &#39;r = (1+2 .. 3+4); r.begin&#39;
assert_equal &#39;7&#39;,               &#39;r = (1+2 .. 3+4); r.end&#39;
assert_equal &#39;false&#39;,           &#39;r = (1+2 .. 3+4); r.exclude_end?&#39;
assert_equal &#39;Range&#39;,           &#39;r = (1+2 ... 3+4); r.class&#39;
assert_equal &#39;3...7&#39;,           &#39;r = (1+2 ... 3+4); r.inspect&#39;
assert_equal &#39;3&#39;,               &#39;r = (1+2 ... 3+4); r.begin&#39;
assert_equal &#39;7&#39;,               &#39;r = (1+2 ... 3+4); r.end&#39;
assert_equal &#39;true&#39;,            &#39;r = (1+2 ... 3+4); r.exclude_end?&#39;
assert_equal &#39;Range&#39;,           &#39;r = (&quot;a&quot;..&quot;c&quot;); r.class&#39;
assert_equal &#39;&quot;a&quot;..&quot;c&quot;&#39;,        &#39;r = (&quot;a&quot;..&quot;c&quot;); r.inspect&#39;
assert_equal &#39;a&#39;,               &#39;r = (&quot;a&quot;..&quot;c&quot;); r.begin&#39;
assert_equal &#39;c&#39;,               &#39;r = (&quot;a&quot;..&quot;c&quot;); r.end&#39;

assert_equal &#39;String&#39;,          &#39;__FILE__.class&#39;
assert_equal &#39;Integer&#39;,         &#39;__LINE__.class&#39;

###

assert_equal &#39;ok&#39;, %q{
  # this cause &quot;called on terminated object&quot;.
  ObjectSpace.each_object(Module) {|m| m.name.inspect }
  :ok
}

assert_normal_exit %q{
  begin
    r = 0**-1
    r + r
  rescue
  end
}, &#39;[ruby-dev:34524]&#39;

assert_normal_exit %q{
  begin
    r = Marshal.load(&quot;\x04\bU:\rRational[\ai\x06i\x05&quot;)
    r + r
  rescue
  end
}, &#39;[ruby-dev:34536]&#39;

assert_equal &#39;ok&#39;, %q{
  &quot;#{}&quot;&quot;#{}ok&quot;
}, &#39;[ruby-dev:38968]&#39;

assert_equal &#39;ok&#39;, %q{
  &quot;#{}o&quot;&quot;#{}k&quot;&quot;#{}&quot;
}, &#39;[ruby-core:25284]&#39;

assert_equal &#39;ok&#39;, %q{ #  long array literal
  x = nil
  eval &quot;a = [#{(1..10_000).map{&#39;x&#39;}.join(&quot;, &quot;)}]&quot;
  :ok
}

assert_equal &#39;ok&#39;, %q{ #  long array literal (optimized)
  eval &quot;a = [#{(1..10_000).to_a.join(&quot;, &quot;)}]&quot;
  :ok
}

assert_equal &#39;ok&#39;, %q{ #  long hash literal
  x = nil
  eval &quot;a = {#{(1..10_000).map{|n| &quot;#{n} =&gt; x&quot;}.join(&#39;, &#39;)}}&quot;
  :ok
}

assert_equal &#39;ok&#39;, %q{ #  long hash literal (optimized)
  eval &quot;a = {#{(1..10_000).map{|n| &quot;#{n} =&gt; #{n}&quot;}.join(&#39;, &#39;)}}&quot;
  :ok
}

assert_equal &#39;ok&#39;, %q{
  [print(:ok), exit] # void literal with side-effect
  :dummy
}
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_flow.out</h2>
      <pre style='float: left; width: 50%'>assert_equal %q{[1, 2, 4, 5, 6, 7, 8]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  [1,2].each{; $a &lt;&lt; 2
    break; $a &lt;&lt; 3
  }; $a &lt;&lt; 4
  begin; $a &lt;&lt; 5
  ensure; $a &lt;&lt; 6
  end; $a &lt;&lt; 7
; $a &lt;&lt; 8
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 5, 6, 7, 8]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  begin; $a &lt;&lt; 2
    [1,2].each do; $a &lt;&lt; 3
      break; $a &lt;&lt; 4
    end; $a &lt;&lt; 5
  ensure; $a &lt;&lt; 6
  end; $a &lt;&lt; 7
; $a &lt;&lt; 8
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{ok}, %q{
  [&quot;a&quot;].inject(&quot;ng&quot;){|x,y|
    break :ok
  }
}
assert_equal %q{ok}, %q{
  unless &#39;&#39;.respond_to? :lines
    class String
      def lines
        self
      end
    end
  end

  (&#39;a&#39;).lines.map{|e|
    break :ok
  }
}
assert_equal %q{[1, 2, 4, 5]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  [&quot;a&quot;].inject(&quot;ng&quot;){|x,y|; $a &lt;&lt; 2
    break :ok; $a &lt;&lt; 3
  }; $a &lt;&lt; 4
; $a &lt;&lt; 5
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 4, 5]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  (&#39;a&#39;..&#39;b&#39;).map{|e|; $a &lt;&lt; 2
    break :ok; $a &lt;&lt; 3
  }; $a &lt;&lt; 4
; $a &lt;&lt; 5
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 5, 7, 8]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  [1,2].each do; $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      break; $a &lt;&lt; 4
    ensure; $a &lt;&lt; 5
    end; $a &lt;&lt; 6
  end; $a &lt;&lt; 7
; $a &lt;&lt; 8
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 5, 6, 9, 10]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  i=0; $a &lt;&lt; 2
  while i&lt;3; $a &lt;&lt; 3
    i+=1; $a &lt;&lt; 4
    begin; $a &lt;&lt; 5
    ensure; $a &lt;&lt; 6
      break; $a &lt;&lt; 7
    end; $a &lt;&lt; 8
  end; $a &lt;&lt; 9
; $a &lt;&lt; 10
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 5, 7, 10, 11]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  i=0; $a &lt;&lt; 2
  while i&lt;3; $a &lt;&lt; 3
    i+=1; $a &lt;&lt; 4
    begin; $a &lt;&lt; 5
      raise; $a &lt;&lt; 6
    ensure; $a &lt;&lt; 7
      break; $a &lt;&lt; 8
    end; $a &lt;&lt; 9
  end; $a &lt;&lt; 10
; $a &lt;&lt; 11
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 5, 7, 10, 11]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  i=0; $a &lt;&lt; 2
  while i&lt;3; $a &lt;&lt; 3
    i+=1; $a &lt;&lt; 4
    begin; $a &lt;&lt; 5
      raise; $a &lt;&lt; 6
    rescue; $a &lt;&lt; 7
      break; $a &lt;&lt; 8
    end; $a &lt;&lt; 9
  end; $a &lt;&lt; 10
; $a &lt;&lt; 11
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 5, 8, 9]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  [1,2].each do; $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      raise StandardError; $a &lt;&lt; 4
    ensure; $a &lt;&lt; 5
      break; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  end; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 5, 8, 9]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  [1,2].each do; $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      raise StandardError; $a &lt;&lt; 4
    rescue; $a &lt;&lt; 5
      break; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  end; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 6, 8, 10, 11]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  [1,2].each do; $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      begin; $a &lt;&lt; 4
        break; $a &lt;&lt; 5
      ensure; $a &lt;&lt; 6
      end; $a &lt;&lt; 7
    ensure; $a &lt;&lt; 8
    end; $a &lt;&lt; 9
  end; $a &lt;&lt; 10
; $a &lt;&lt; 11
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 5, 6, 7, 8, 10, 13, 3, 4, 5, 6, 7, 8, 10, 13, 3, 4, 5, 6, 7, 8, 10, 13, 14, 15]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  i = 0; $a &lt;&lt; 2
  while i&lt;3; $a &lt;&lt; 3
    i+=1; $a &lt;&lt; 4
    j = 0; $a &lt;&lt; 5
    while j&lt;3; $a &lt;&lt; 6
      j+=1; $a &lt;&lt; 7
      begin; $a &lt;&lt; 8
        raise; $a &lt;&lt; 9
      rescue; $a &lt;&lt; 10
        break; $a &lt;&lt; 11
      end; $a &lt;&lt; 12
    end; $a &lt;&lt; 13
  end; $a &lt;&lt; 14
; $a &lt;&lt; 15
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 15, 3, 4, 5, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 15, 3, 4, 5, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 15, 16, 17]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  i = 0; $a &lt;&lt; 2
  while i&lt;3; $a &lt;&lt; 3
    i+=1; $a &lt;&lt; 4
    j = 0; $a &lt;&lt; 5
    while j&lt;3; $a &lt;&lt; 6
      j+=1; $a &lt;&lt; 7
      1.times{; $a &lt;&lt; 8
        begin; $a &lt;&lt; 9
          raise; $a &lt;&lt; 10
        rescue; $a &lt;&lt; 11
          break; $a &lt;&lt; 12
        end; $a &lt;&lt; 13
      }; $a &lt;&lt; 14
    end; $a &lt;&lt; 15
  end; $a &lt;&lt; 16
; $a &lt;&lt; 17
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 5, 6, 7, 8, 10, 13, 3, 4, 5, 6, 7, 8, 10, 13, 3, 4, 5, 6, 7, 8, 10, 13, 14, 15]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  i = 0; $a &lt;&lt; 2
  while i&lt;3; $a &lt;&lt; 3
    i+=1; $a &lt;&lt; 4
    j = 0; $a &lt;&lt; 5
    while j&lt;3; $a &lt;&lt; 6
      j+=1; $a &lt;&lt; 7
      begin; $a &lt;&lt; 8
        raise; $a &lt;&lt; 9
      ensure; $a &lt;&lt; 10
        break; $a &lt;&lt; 11
      end; $a &lt;&lt; 12
    end; $a &lt;&lt; 13
  end; $a &lt;&lt; 14
; $a &lt;&lt; 15
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 15, 3, 4, 5, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 15, 3, 4, 5, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 6, 7, 8, 9, 11, 14, 15, 16, 17]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  i = 0; $a &lt;&lt; 2
  while i&lt;3; $a &lt;&lt; 3
    i+=1; $a &lt;&lt; 4
    j = 0; $a &lt;&lt; 5
    while j&lt;3; $a &lt;&lt; 6
      j+=1; $a &lt;&lt; 7
      1.times{; $a &lt;&lt; 8
        begin; $a &lt;&lt; 9
          raise; $a &lt;&lt; 10
        ensure; $a &lt;&lt; 11
          break; $a &lt;&lt; 12
        end; $a &lt;&lt; 13
      }; $a &lt;&lt; 14
    end; $a &lt;&lt; 15
  end; $a &lt;&lt; 16
; $a &lt;&lt; 17
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 5, 8, 9]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  while true; $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      break; $a &lt;&lt; 4
    ensure; $a &lt;&lt; 5
      break; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  end; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 5, 99]}, %q{
$a = [];
begin; ; $a &lt;&lt; 1
  while true; $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      break; $a &lt;&lt; 4
    ensure; $a &lt;&lt; 5
      raise; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  end; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 6, 8, 9, 10, 11]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  begin; $a &lt;&lt; 2
    [1,2].each do; $a &lt;&lt; 3
      begin; $a &lt;&lt; 4
        break; $a &lt;&lt; 5
      ensure; $a &lt;&lt; 6
      end; $a &lt;&lt; 7
    end; $a &lt;&lt; 8
  ensure; $a &lt;&lt; 9
  end; $a &lt;&lt; 10
; $a &lt;&lt; 11
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 4, 99]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  begin; $a &lt;&lt; 2
    raise StandardError; $a &lt;&lt; 3
  ensure; $a &lt;&lt; 4
  end; $a &lt;&lt; 5
; $a &lt;&lt; 6
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  begin; $a &lt;&lt; 2
  ensure; $a &lt;&lt; 3
  end ; $a &lt;&lt; 4
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 5, 99]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  [1,2].each do; $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      break; $a &lt;&lt; 4
    ensure; $a &lt;&lt; 5
      raise StandardError; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  end; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{3}, %q{
  def m a, b
    a + b
  end
  m(1,
    while true
      break 2
    end
    )
}
assert_equal %q{4}, %q{
  def m a, b
    a + b
  end
  m(1,
    (i=0; while i&lt;2
       i+=1
       class C
         next 2
       end
     end; 3)
    )
}
assert_equal %q{34}, %q{
  def m a, b
    a+b
  end
  m(1, 1.times{break 3}) +
  m(10, (1.times{next 3}; 20))
}
assert_equal %q{[1, 2, 3, 6, 7]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  3.times{; $a &lt;&lt; 2
    class C; $a &lt;&lt; 3
      break; $a &lt;&lt; 4
    end; $a &lt;&lt; 5
  }; $a &lt;&lt; 6
; $a &lt;&lt; 7
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 8, 9]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  3.times{; $a &lt;&lt; 2
    class A; $a &lt;&lt; 3
      class B; $a &lt;&lt; 4
        break; $a &lt;&lt; 5
      end; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  }; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 2, 3, 2, 3, 6, 7]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  3.times{; $a &lt;&lt; 2
    class C; $a &lt;&lt; 3
      next; $a &lt;&lt; 4
    end; $a &lt;&lt; 5
  }; $a &lt;&lt; 6
; $a &lt;&lt; 7
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 2, 3, 4, 2, 3, 4, 8, 9]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  3.times{; $a &lt;&lt; 2
    class C; $a &lt;&lt; 3
      class D; $a &lt;&lt; 4
        next; $a &lt;&lt; 5
      end; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  }; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 6, 7]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  while true; $a &lt;&lt; 2
    class C; $a &lt;&lt; 3
      break; $a &lt;&lt; 4
    end; $a &lt;&lt; 5
  end; $a &lt;&lt; 6
; $a &lt;&lt; 7
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 8, 9]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  while true; $a &lt;&lt; 2
    class C; $a &lt;&lt; 3
      class D; $a &lt;&lt; 4
        break; $a &lt;&lt; 5
      end; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  end; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 3, 4, 5, 3, 4, 5, 3, 4, 5, 8, 9]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  i=0; $a &lt;&lt; 2
  while i&lt;3; $a &lt;&lt; 3
    i+=1; $a &lt;&lt; 4
    class C; $a &lt;&lt; 5
      next 10; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  end; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{1}, %q{
  1.times{
    while true
      class C
        begin
          break
        ensure
          break
        end
      end
    end
  }
}
assert_equal %q{[1, 2, 3, 5, 2, 3, 5, 7, 8]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  [1,2].each do; $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      next; $a &lt;&lt; 4
    ensure; $a &lt;&lt; 5
    end; $a &lt;&lt; 6
  end; $a &lt;&lt; 7
; $a &lt;&lt; 8
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 2, 6, 3, 5, 7, 8]}, %q{$a = []; begin;  ; $a &lt;&lt; 1
  o = &quot;test&quot;; $a &lt;&lt; 2
  def o.test(a); $a &lt;&lt; 3
    return a; $a &lt;&lt; 4
  ensure; $a &lt;&lt; 5
  end; $a &lt;&lt; 6
  o.test(123); $a &lt;&lt; 7
; $a &lt;&lt; 8
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 4, 7, 5, 8, 9]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  def m1 *args; $a &lt;&lt; 2
    ; $a &lt;&lt; 3
  end; $a &lt;&lt; 4
  def m2; $a &lt;&lt; 5
    m1(:a, :b, (return 1; :c)); $a &lt;&lt; 6
  end; $a &lt;&lt; 7
  m2; $a &lt;&lt; 8
; $a &lt;&lt; 9
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 8, 2, 3, 4, 5, 9, 10]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  def m(); $a &lt;&lt; 2
    begin; $a &lt;&lt; 3
      2; $a &lt;&lt; 4
    ensure; $a &lt;&lt; 5
      return 3; $a &lt;&lt; 6
    end; $a &lt;&lt; 7
  end; $a &lt;&lt; 8
  m; $a &lt;&lt; 9
; $a &lt;&lt; 10
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 3, 11, 4, 5, 6, 7, 12, 13]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  def m2; $a &lt;&lt; 2
  end; $a &lt;&lt; 3
  def m(); $a &lt;&lt; 4
    m2(begin; $a &lt;&lt; 5
         2; $a &lt;&lt; 6
       ensure; $a &lt;&lt; 7
         return 3; $a &lt;&lt; 8
       end); $a &lt;&lt; 9
    4; $a &lt;&lt; 10
  end; $a &lt;&lt; 11
  m(); $a &lt;&lt; 12
; $a &lt;&lt; 13
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[1, 16, 2, 3, 4, 5, 6, 7, 10, 11, 17, 18]}, %q{$a = []; begin; ; $a &lt;&lt; 1
  def m; $a &lt;&lt; 2
    1; $a &lt;&lt; 3
    1.times{; $a &lt;&lt; 4
      2; $a &lt;&lt; 5
      begin; $a &lt;&lt; 6
        3; $a &lt;&lt; 7
        return; $a &lt;&lt; 8
        4; $a &lt;&lt; 9
      ensure; $a &lt;&lt; 10
        5; $a &lt;&lt; 11
      end; $a &lt;&lt; 12
      6; $a &lt;&lt; 13
    }; $a &lt;&lt; 14
    7; $a &lt;&lt; 15
  end; $a &lt;&lt; 16
  m(); $a &lt;&lt; 17
; $a &lt;&lt; 18
; rescue Exception; $a &lt;&lt; 99; end; $a}
assert_equal %q{[:ok, :ok2, :last]}, %q{
  a = []
  i = 0
  begin
    while i &lt; 1
      i+=1
      begin
        begin
          next
        ensure
          a &lt;&lt; :ok
        end
      ensure
        a &lt;&lt; :ok2
      end
    end
  ensure
    a &lt;&lt; :last
  end
  a
}
assert_equal %q{[:ok, :ok2, :last]}, %q{
  a = []
  i = 0
  begin
    while i &lt; 1
      i+=1
      begin
        begin
          break
        ensure
          a &lt;&lt; :ok
        end
      ensure
        a &lt;&lt; :ok2
      end
    end
  ensure
    a &lt;&lt; :last
  end
  a
}
assert_equal %q{[:ok, :ok2, :last]}, %q{
  a = []
  i = 0
  begin
    while i &lt; 1
      if i&gt;0
        break
      end
      i+=1
      begin
        begin
          redo
        ensure
          a &lt;&lt; :ok
        end
      ensure
        a &lt;&lt; :ok2
      end
    end
  ensure
    a &lt;&lt; :last
  end
  a
}
assert_equal %Q{ENSURE\n}, %q{
  def test
    while true
      return
    end
  ensure
    puts(&quot;ENSURE&quot;)
  end
  test
}, &#39;[ruby-dev:37967]&#39;

[[&#39;[ruby-core:28129]&#39;, %q{
  class Bug2728
    include Enumerable
    define_method(:dynamic_method) do
      &quot;dynamically defined method&quot;
    end
    def each
      begin
        yield :foo
      ensure
        dynamic_method
      end
    end
  end
  e = Bug2728.new
}],
 [&#39;[ruby-core:28132]&#39;, %q{
  class Bug2729
    include Enumerable
    def each
      begin
        yield :foo
      ensure
        proc {}.call
      end
    end
  end
  e = Bug2729.new
}],
 [&#39;[ruby-core:39125]&#39;, %q{
  class Bug5234
    include Enumerable
    def each
      begin
        yield :foo
      ensure
        proc
      end
    end
  end
  e = Bug5234.new
}],
 [&#39;[ruby-dev:45656]&#39;, %q{
  class Bug6460
    include Enumerable
    def each
      begin
        yield :foo
      ensure
        1.times { Proc.new }
      end
    end
  end
  e = Bug6460.new
}]].each do |bug, src|
  assert_equal &quot;foo&quot;, src + %q{e.detect {true}}, bug
  assert_equal &quot;true&quot;, src + %q{e.any? {true}}, bug
  assert_equal &quot;false&quot;, src + %q{e.all? {false}}, bug
  assert_equal &quot;true&quot;, src + %q{e.include?(:foo)}, bug
end

assert_equal &quot;foo&quot;, %q{
  class Bug6460
    def m1
      m2 {|e|
        return e
      }
    end

    def m2
      begin
        yield :foo
      ensure
        begin
          begin
            yield :foo
          ensure
            Proc.new
            raise &#39;&#39;
          end
        rescue
        end
      end
    end
  end
  Bug6460.new.m1
}, &#39;[ruby-dev:46372]&#39;
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_syntax.out</h2>
      <pre style='float: left; width: 50%'>assert_equal %q{4}, %q{1 &amp;&amp; 2 &amp;&amp; 3 &amp;&amp; 4}
assert_equal %q{}, %q{1 &amp;&amp; nil &amp;&amp; 3 &amp;&amp; 4}
assert_equal %q{}, %q{1 &amp;&amp; 2 &amp;&amp; 3 &amp;&amp; nil}
assert_equal %q{false}, %q{1 &amp;&amp; 2 &amp;&amp; 3 &amp;&amp; false}
assert_equal %q{4}, %q{1 and 2 and 3 and 4}
assert_equal %q{}, %q{1 and nil and 3 and 4}
assert_equal %q{}, %q{1 and 2 and 3 and nil}
assert_equal %q{false}, %q{1 and 2 and 3 and false}
assert_equal %q{}, %q{nil &amp;&amp; true}
assert_equal %q{false}, %q{false &amp;&amp; true}
assert_equal %q{}, %q{
  case 1
  when 2
    :ng
  end}
assert_equal %q{ok}, %q{
  case 1
  when 10,20,30
    :ng1
  when 1,2,3
    :ok
  when 100,200,300
    :ng2
  else
    :elseng
  end}
assert_equal %q{elseok}, %q{
  case 123
  when 10,20,30
    :ng1
  when 1,2,3
    :ng2
  when 100,200,300
    :ng3
  else
    :elseok
  end
}
assert_equal %q{ok}, %q{
  case &#39;test&#39;
  when /testx/
    :ng1
  when /test/
    :ok
  when /tetxx/
    :ng2
  else
    :ng_else
  end
}
assert_equal %q{ok}, %q{
  case Object.new
  when Object
    :ok
  end
}
assert_equal %q{ok}, %q{
  case Object
  when Object.new
    :ng
  else
    :ok
  end
}
assert_equal %q{ok}, %q{
  case &#39;test&#39;
  when &#39;tes&#39;
    :ng
  when &#39;te&#39;
    :ng
  else
    :ok
  end
}
assert_equal %q{ok}, %q{
  case &#39;test&#39;
  when &#39;tes&#39;
    :ng
  when &#39;te&#39;
    :ng
  when &#39;test&#39;
    :ok
  end
}
assert_equal %q{ng}, %q{
  case &#39;test&#39;
  when &#39;tes&#39;
    :ng
  when /te/
    :ng
  else
    :ok
  end
}
assert_equal %q{ok}, %q{
  case &#39;test&#39;
  when &#39;tes&#39;
    :ng
  when /test/
    :ok
  else
    :ng
  end
}
assert_equal %q{100}, %q{
  def test(arg)
    case 1
    when 2
      3
    end
    return arg
  end

  test(100)
}
assert_equal %q{ok}, %q{
  ary = [1, 2]
  case 1
  when *ary
    :ok
  else
    :ng
  end
}
assert_equal %q{ok}, %q{
  ary = [1, 2]
  case 3
  when *ary
    :ng
  else
    :ok
  end
}
assert_equal %q{ok}, %q{
  ary = [1, 2]
  case 1
  when :x, *ary
    :ok
  when :z
    :ng1
  else
    :ng2
  end
}
assert_equal %q{ok}, %q{
  ary = [1, 2]
  case 3
  when :x, *ary
    :ng1
  when :z
    :ng2
  else
    :ok
  end
}
assert_equal %q{[:false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep]}, %q{

  def make_perm ary, num
    if num == 1
      ary.map{|e| [e]}
    else
      base = make_perm(ary, num-1)
      res  = []
      base.each{|b|
        ary.each{|e|
          res &lt;&lt; [e] + b
        }
      }
      res
    end
  end

  def each_test
    conds = make_perm([&#39;fv&#39;, &#39;tv&#39;], 3)
    bangs = make_perm([&#39;&#39;, &#39;!&#39;], 3)
    exprs = make_perm([&#39;and&#39;, &#39;or&#39;], 3)
    [&#39;if&#39;, &#39;unless&#39;].each{|syn|
      conds.each{|cs|
        bangs.each{|bs|
          exprs.each{|es|
            yield(syn, cs, bs, es)
          }
        }
      }
    }
  end

  fv = false
  tv = true

  $ans = []
  each_test{|syn, conds, bangs, exprs|
    c1, c2, c3 = conds
    bang1, bang2, bang3 = bangs
    e1, e2 = exprs
    eval %Q{
      #{syn} #{bang1}#{c1} #{e1} #{bang2}#{c2} #{e2} #{bang3}#{c3}
        $ans &lt;&lt; :then
      else
        $ans &lt;&lt; :false
      end
    }
  }

  each_test{|syn, conds, bangs, exprs|
    c1, c2, c3 = conds
    bang1, bang2, bang3 = bangs
    e1, e2 = exprs
    eval %Q{
      #{syn} #{bang1}#{c1} #{e1} #{bang2}#{c2} #{e2} #{bang3}#{c3}
        $ans &lt;&lt; :then
      end
      $ans &lt;&lt; :sep
    }
  }
  $ans
}
assert_equal %q{}, %q{
  defined?(m)
}
assert_equal %q{method}, %q{
  def m
  end
  defined?(m)
}
assert_equal %q{}, %q{
  defined?(a.class)
}
assert_equal %q{method}, %q{
  a = 1
  defined?(a.class)
}
assert_equal %q{[&quot;method&quot;, &quot;method&quot;, &quot;method&quot;, &quot;method&quot;, nil, nil, &quot;method&quot;, &quot;method&quot;, &quot;method&quot;, nil]}, %q{
  class C
    def test
      [defined?(m1()), defined?(self.m1), defined?(C.new.m1),
       defined?(m2()), defined?(self.m2), defined?(C.new.m2),
       defined?(m3()), defined?(self.m3), defined?(C.new.m3)]
    end
    def m1
    end
    private
    def m2
    end
    protected
    def m3
    end
  end
  C.new.test + [defined?(C.new.m3)]
}
assert_equal %q{[nil, nil, nil, nil, &quot;global-variable&quot;, &quot;global-variable&quot;, nil, nil]}, %q{
  $ans = [defined?($1), defined?($2), defined?($3), defined?($4)]
  /(a)(b)/ =~ &#39;ab&#39;
  $ans + [defined?($1), defined?($2), defined?($3), defined?($4)]
}
assert_equal %q{nilselftruefalse}, %q{
  defined?(nil) + defined?(self) +
    defined?(true) + defined?(false)
}
assert_equal %q{}, %q{
  defined?(@a)
}
assert_equal %q{instance-variable}, %q{
  @a = 1
  defined?(@a)
}
assert_equal %q{}, %q{
  defined?(@@a)
}
assert_equal %q{class variable}, %q{
  @@a = 1
  defined?(@@a)
}
assert_equal %q{}, %q{
  defined?($a)
}
assert_equal %q{global-variable}, %q{
  $a = 1
  defined?($a)
}
assert_equal %q{}, %q{
  defined?(C_definedtest)
}
assert_equal %q{constant}, %q{
  C_definedtest = 1
  defined?(C_definedtest)
}
assert_equal %q{}, %q{
  defined?(::C_definedtest)
}
assert_equal %q{constant}, %q{
  C_definedtest = 1
  defined?(::C_definedtest)
}
assert_equal %q{}, %q{
  defined?(C_definedtestA::C_definedtestB::C_definedtestC)
}
assert_equal %q{constant}, %q{
  class C_definedtestA
    class C_definedtestB
      C_definedtestC = 1
    end
  end
  defined?(C_definedtestA::C_definedtestB::C_definedtestC)
}
assert_equal %q{30}, %q{
  sum = 0
  30.times{|ib|
    if ib % 10 == 0 .. true
      sum += ib
    end
  }
  sum
}
assert_equal %q{63}, %q{
  sum = 0
  30.times{|ib|
    if ib % 10 == 0 ... true
      sum += ib
    end
  }
  sum
}
assert_equal %q{[[&quot;NUM&quot;, &quot;Type: NUM\n&quot;], [&quot;NUM&quot;, &quot;123\n&quot;], [&quot;NUM&quot;, &quot;456\n&quot;], [&quot;NUM&quot;, &quot;Type: ARP\n&quot;], [&quot;NUM&quot;, &quot;aaa\n&quot;], [&quot;NUM&quot;, &quot;bbb\n&quot;], [&quot;NUM&quot;, &quot;\f\n&quot;], [&quot;ARP&quot;, &quot;Type: ARP\n&quot;], [&quot;ARP&quot;, &quot;aaa\n&quot;], [&quot;ARP&quot;, &quot;bbb\n&quot;]]}, %q{
  t = nil
  unless &#39;&#39;.respond_to? :lines
    class String
      def lines
        self
      end
    end
  end
  ary = []
&quot;this must not print
Type: NUM
123
456
Type: ARP
aaa
bbb
\f
this must not print
hoge
Type: ARP
aaa
bbb
&quot;.lines.each{|l|
    if (t = l[/^Type: (.*)/, 1])..(/^\f/ =~ l)
      ary &lt;&lt; [t, l]
    end
  }
  ary
}
assert_equal %q{1}, %q{if true  then 1 ; end}
assert_equal %q{}, %q{if false then 1 ; end}
assert_equal %q{1}, %q{if true  then 1 ; else; 2; end}
assert_equal %q{2}, %q{if false then 1 ; else; 2; end}
assert_equal %q{}, %q{if true  then   ; elsif true then ; 1 ; end}
assert_equal %q{1}, %q{if false then   ; elsif true then ; 1 ; end}
assert_equal %q{}, %q{unless true  then 1 ; end}
assert_equal %q{1}, %q{unless false then 1 ; end}
assert_equal %q{2}, %q{unless true  then 1 ; else; 2; end}
assert_equal %q{1}, %q{unless false then 1 ; else; 2; end}
assert_equal %q{1}, %q{1 if true}
assert_equal %q{}, %q{1 if false}
assert_equal %q{}, %q{1 if nil}
assert_equal %q{}, %q{1 unless true}
assert_equal %q{1}, %q{1 unless false}
assert_equal %q{1}, %q{1 unless nil}
assert_equal %q{1}, %q{1 || 2 || 3 || 4}
assert_equal %q{1}, %q{1 || false || 3 || 4}
assert_equal %q{2}, %q{nil || 2 || 3 || 4}
assert_equal %q{2}, %q{false || 2 || 3 || 4}
assert_equal %q{false}, %q{nil || false || nil || false}
assert_equal %q{1}, %q{1 or 2 or 3 or 4}
assert_equal %q{1}, %q{1 or false or 3 or 4}
assert_equal %q{2}, %q{nil or 2 or 3 or 4}
assert_equal %q{2}, %q{false or 2 or 3 or 4}
assert_equal %q{1}, %q{if true &amp;&amp; &quot;&quot;; then 1; end}
assert_equal %q{1}, %q{if nil || true; then 1; end}
assert_equal %q{false}, %q{nil or false or nil or false}
assert_equal %q{elseng}, %q{
  case
  when 1==2, 2==3
    :ng1
  when false, 4==5
    :ok
  when false
    :ng2
  else
    :elseng
  end
}
assert_equal %q{ok}, %q{
  case
  when nil, nil
    :ng1
  when 1,2,3
    :ok
  when false, false
    :ng2
  else
    :elseng
  end
}
assert_equal %q{elseok}, %q{
  case
  when nil
    :ng1
  when false
    :ng2
  else
    :elseok
  end}
assert_equal %q{}, %q{
  case
  when 1
  end
}
assert_equal %q{ok}, %q{
  r = nil
  ary = []
  case
  when false
    r = :ng1
  when false, false
    r = :ng2
  when *ary
    r = :ng3
  when false, *ary
    r = :ng4
  when true, *ary
    r = :ok
  end
  r
}
assert_equal %q{ok}, %q{
  ary = []
  case
  when false, *ary
    :ng
  else
    :ok
  end
}
assert_equal %q{ok}, %q{
  ary = [false, nil]
  case
  when *ary
    :ng
  else
    :ok
  end
}
assert_equal %q{ok}, %q{
  ary = [false, nil]
  case
  when *ary
    :ng
  when true
    :ok
  else
    :ng2
  end
}
assert_equal %q{ng}, %q{
  ary = [false, nil]
  case
  when *ary
    :ok
  else
    :ng
  end
}
assert_equal %q{ok}, %q{
  ary = [false, true]
  case
  when *ary
    :ok
  else
    :ng
  end
}
assert_equal %q{ok}, %q{
  ary = [false, true]
  case
  when false, false
  when false, *ary
    :ok
  else
    :ng
  end
}
assert_equal %q{}, %q{
  i = 0
  while i &lt; 10
    i+=1
  end}
assert_equal %q{10}, %q{
  i = 0
  while i &lt; 10
    i+=1
  end; i}
assert_equal %q{}, %q{
  i = 0
  until i &gt; 10
    i+=1
  end}
assert_equal %q{11}, %q{
  i = 0
  until i &gt; 10
    i+=1
  end; i}
assert_equal %q{1}, %q{
  i = 0
  begin
    i+=1
  end while false
  i
}
assert_equal %q{1}, %q{
  i = 0
  begin
    i+=1
  end until true
  i
}
def assert_syntax_error expected, code, message = &#39;&#39;
  assert_equal &quot;#{expected}&quot;,
    &quot;begin eval(%q{#{code}}, nil, &#39;&#39;, 0)&quot; + &#39;; rescue SyntaxError =&gt; e; e.message[/\A:(?:\d+:)? (.*)/, 1] end&#39;, message
end
assert_syntax_error &quot;unterminated string meets end of file&quot;, &#39;()..&quot;&#39;, &#39;[ruby-dev:29732]&#39;
assert_equal %q{[]}, %q{$&amp;;[]}, &#39;[ruby-dev:31068]&#39;
assert_syntax_error &quot;syntax error, unexpected *, expecting &#39;}&#39;&quot;, %q{{*0}}, &#39;[ruby-dev:31072]&#39;
assert_syntax_error &quot;`@0&#39; is not allowed as an instance variable name&quot;, %q{@0..0}, &#39;[ruby-dev:31095]&#39;
assert_syntax_error &quot;identifier $00 is not valid to get&quot;, %q{$00..0}, &#39;[ruby-dev:31100]&#39;
assert_syntax_error &quot;identifier $00 is not valid to set&quot;, %q{0..$00=1}
assert_equal %q{0}, %q{[*0];0}, &#39;[ruby-dev:31102]&#39;
assert_syntax_error &quot;syntax error, unexpected &#39;)&#39;&quot;, %q{v0,(*,v1,) = 0}, &#39;[ruby-dev:31104]&#39;
assert_equal %q{1}, %q{
  class &lt;&lt; (ary=[]); def []; 0; end; def []=(x); super(0,x);end;end; ary[]+=1
}, &#39;[ruby-dev:31110]&#39;
assert_syntax_error &quot;Can&#39;t set variable $1&quot;, %q{0..$1=1}, &#39;[ruby-dev:31118]&#39;
assert_valid_syntax %q{1.times{1+(1&amp;&amp;next)}}, &#39;[ruby-dev:31119]&#39;
assert_valid_syntax %q{x=-1;loop{x+=1&amp;&amp;redo if (x+=1).zero?}}, &#39;[ruby-dev:31119]&#39;
assert_syntax_error %q{syntax error, unexpected end-of-input}, %q{!}, &#39;[ruby-dev:31243]&#39;
assert_equal %q{[nil]}, %q{[()]}, &#39;[ruby-dev:31252]&#39;
assert_equal %q{true}, %q{!_=()}, &#39;[ruby-dev:31263]&#39;
assert_equal &#39;ok&#39;, %q{while true; redo; end if 1 == 2; :ok}, &#39;[ruby-dev:31360]&#39;
assert_equal &#39;ok&#39;, %q{
  1.times {
    begin
    ensure
      next
    end
  }; :ok
}, &#39;[ruby-dev:31373]&#39;
assert_equal &#39;ok&#39;, %q{
  flag = false
  1.times {
    next if flag
    flag = true
    begin
    ensure
      redo
    end
  }; :ok
}, &#39;[ruby-dev:31373]&#39;

assert_equal &#39;ok&#39;, %q{
  1.times{
    p(1, (next; 2))
  }; :ok
}
assert_equal &#39;3&#39;, %q{
  i = 0
  1 + (while true
         break 2 if (i+=1) &gt; 1
         next
       end)
}
assert_equal &#39;3&#39;, %q{
  i = 0
  1 + (while true
         break 2 if (i+=1) &gt; 1
         p(1, (next; 2))
       end)
}
# redo
assert_equal &#39;ok&#39;, %q{
  i = 0
  1.times{
    break if i&gt;1
    i+=1
    p(1, (redo; 2))
  }; :ok
}
assert_equal &#39;3&#39;, %q{
  i = 0
  1 + (while true
         break 2 if (i+=1) &gt; 1
         redo
       end)
}
assert_equal &#39;3&#39;, %q{
  i = 0
  1 + (while true
         break 2 if (i+=1) &gt; 1
         p(1, (redo; 2))
       end)
}
assert_equal &#39;1&#39;, %q{
  a = [0]
  a[*a]+=1
}
assert_equal &#39;2&#39;, %q{
  ary = [0]
  case 1
  when *ary, 1
    1
  end +
  case
  when *ary
    1
  end
}

assert_match /invalid multibyte char/, %q{
  STDERR.reopen(STDOUT)
  eval(&quot;\&quot;\xf0&quot;.force_encoding(&quot;utf-8&quot;))
}, &#39;[ruby-dev:32429]&#39;

# method ! and !=
assert_equal &#39;true&#39;, %q{!false}
assert_equal &#39;true&#39;, %q{1 == 1}
assert_equal &#39;true&#39;, %q{1 != 2}
assert_equal &#39;true&#39;, %q{
  class C; def !=(obj); true; end; end
  C.new != 1
}
assert_equal &#39;true&#39;, %q{
  class C; def !@; true; end; end
  !C.new
}
assert_normal_exit %q{
  eval &quot;while true; return; end rescue p $!&quot;
}, &#39;[ruby-dev:31663]&#39;
assert_equal &#39;1&#39;, %q{
  def bar
    raise
  end

  def foo
    1.times{
      begin
        return bar
      rescue
        :ok
      end
    }
  end

  foo
}

assert_equal &#39;ok&#39;, %q{
  counter = 2
  while true
    counter -= 1
    next if counter != 0
    break
  end
  :ok
}, &#39;[ruby-core:14385]&#39;

assert_equal &#39;ok&#39;, %q{
  counter = 2
  while true
    counter -= 1
    next if counter != 0
    break :ok
  end # direct
}, &#39;[ruby-core:14385]&#39;

assert_equal &#39;ok&#39;, %q{
  counter = 2
  while true
    counter -= 1
    break if counter == 0
    &quot;#{next}&quot;
  end
  :ok
}, &#39;reported by Yusuke ENDOH&#39;

assert_equal &#39;ok&#39;, %q{
  counter = 2
  while true
    counter -= 1
    break if counter == 0
    next
    redo
  end
  :ok
}, &#39;reported by Yusuke ENDOH&#39;

assert_equal &#39;ok&#39;, %q{
  counter = 2
  while true
    counter -= 1
    break if counter == 0
    next
    &quot;#{ redo }&quot;
  end
  :ok
}, &#39;reported by Yusuke ENDOH&#39;

assert_normal_exit %q{
  begin
    raise
  rescue
    counter = 2
    while true
      counter -= 1
      break if counter == 0
      next
      retry
    end
  end
}, &#39;reported by Yusuke ENDOH&#39;

assert_normal_exit %q{
  counter = 2
  while true
    counter -= 1
    break if counter == 0
    next
    &quot;#{ break }&quot;
  end
}, &#39;reported by Yusuke ENDOH&#39;

assert_normal_exit %q{
  counter = 2
  while true
    counter -= 1
    next if counter != 0
    &quot;#{ break }&quot;
  end
}, &#39;reported by Yusuke ENDOH&#39;

assert_equal &#39;ok&#39;, %q{
  1.times do
    [
      1, 2, 3, 4, 5, 6, 7, 8,
      begin
        false ? next : p
        break while true
      end
    ]
  end
  :ok
}, &#39;[ruby-dev:32882]&#39;

assert_equal &quot;1\n2\n&quot;, %q{
  i = 0
  while i&lt;2
    i += 1
    next p(i)
  end
}

assert_valid_syntax(&#39;1.times {|i|print (42),1;}&#39;, &#39;[ruby-list:44479]&#39;)

assert_equal &#39;ok&#39;, %q{
  def a() end
  begin
    if defined?(a(1).a)
      :ng
    else
      :ok
    end
  rescue
    :ng
  end
}, &#39;[ruby-core:16010]&#39;

assert_equal &#39;ok&#39;, %q{
  def a() end
  begin
    if defined?(a::B)
      :ng
    else
      :ok
    end
  rescue
    :ng
  end
}, &#39;[ruby-core:16010]&#39;

assert_normal_exit %q{
  defined? C &amp;&amp; 0
}

assert_normal_exit %q{
  class C
    def m
      defined?(super())
    end
  end
  C.new.m
}

assert_equal &#39;ok&#39;, %q{
  class X &lt; RuntimeError;end
  x = [X]
  begin
   raise X
  rescue *x
   :ok
  end
}, &#39;[ruby-core:14537]&#39;

assert_equal &#39;ok&#39;, %q{
  a = [false]
  (a[0] &amp;&amp;= true) == false ? :ok : :ng
}, &#39;[ruby-dev:34679]&#39;

assert_normal_exit %q{
  a = []
  100.times {|i| a &lt;&lt; i &lt;&lt; nil &lt;&lt; nil }
  p a.compact!
}

assert_equal &#39;ok&#39;, %q{
  &quot;#{}&quot;&quot;#{}ok&quot;
}, &#39;[ruby-dev:38968]&#39;


assert_equal &#39;ok&#39;, %q{
  &quot;o&quot; &quot;#{}k&quot;
}, &#39;[ruby-dev:38980]&#39;

bug2415 = &#39;[ruby-core:26961]&#39;
assert_normal_exit %q{
  0.times do
    0.times do
      def x(a=1, b, *rest); nil end
    end
  end
}, bug2415

assert_normal_exit %q{
  0.times do
    0.times do
      def x@; nil end
    end
  end
}, bug2415

assert_normal_exit %q{
  0.times do
    0.times do
      def x(a = 0.times do
              def y(a=1, b, *rest); nil; end
            end)
        nil
      end
    end
  end
}, bug2415

assert_normal_exit %q{
  0.times do
    0.times do
      def x(a = 0.times do
              def x@; nil; end
            end)
        nil
      end
    end
  end
}, bug2415

assert_normal_exit %q{
  a {
    b {|c.d| }
    e
  }
}, &#39;[ruby-dev:39861]&#39;

bug1240 = &#39;[ruby-core:22637]&#39;
assert_valid_syntax(&#39;x y { &quot;#{}&quot;.z { } }&#39;, bug1240)
assert_valid_syntax(&#39;x y { &quot;#{}&quot;.z do end }&#39;, bug1240)

assert_valid_syntax(&#39;y &quot;#{a 1}&quot; do end&#39;, &#39;[ruby-core:29579]&#39;)
assert_normal_exit %q{
  def foo(&amp;block)
    yield
  end

  foo do
    s = defined?(raise + 1)
    Class
  end
}, &#39;[ruby-core:30293]&#39;
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_method.out</h2>
      <pre style='float: left; width: 50%'># regular argument
assert_equal &#39;1&#39;,       &#39;def m() 1 end; m()&#39;
assert_equal &#39;1&#39;,       &#39;def m(a) a end; m(1)&#39;
assert_equal &#39;[1, 2]&#39;,  &#39;def m(a,b) [a, b] end; m(1,2)&#39;
assert_equal &#39;[1, 2, 3]&#39;, &#39;def m(a,b,c) [a, b, c] end; m(1,2,3)&#39;
assert_match /\Awrong number of arguments \(.*\b1\b.* 0\)\z/, %q{
  def m; end
  begin
    m(1)
  rescue =&gt; e
    e.message
  end
}

assert_match /\Awrong number of arguments \(.*\b0\b.* 1\)\z/, %q{
  def m a; end
  begin
    m
  rescue =&gt; e
    e.message
  end
}

# default argument
assert_equal &#39;1&#39;,       &#39;def m(x=1) x end; m()&#39;
assert_equal &#39;1&#39;,       &#39;def m(x=7) x end; m(1)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,x=1) x end; m(7)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,x=7) x end; m(7,1)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b,x=1) x end; m(7,7)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b,x=7) x end; m(7,7,1)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,x=1,y=1) x end; m(7)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,x=1,y=1) y end; m(7)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,x=7,y=1) x end; m(7,1)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,x=7,y=1) y end; m(7,1)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,x=7,y=7) x end; m(7,1,1)&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,x=7,y=7) y end; m(7,1,1)&#39;

# rest argument
assert_equal &#39;[]&#39;,      &#39;def m(*a) a end; m().inspect&#39;
assert_equal &#39;[1]&#39;,     &#39;def m(*a) a end; m(1).inspect&#39;
assert_equal &#39;[1, 2]&#39;,  &#39;def m(*a) a end; m(1,2).inspect&#39;
assert_equal &#39;[]&#39;,      &#39;def m(x,*a) a end; m(7).inspect&#39;
assert_equal &#39;[1]&#39;,     &#39;def m(x,*a) a end; m(7,1).inspect&#39;
assert_equal &#39;[1, 2]&#39;,  &#39;def m(x,*a) a end; m(7,1,2).inspect&#39;
assert_equal &#39;[]&#39;,      &#39;def m(x,y,*a) a end; m(7,7).inspect&#39;
assert_equal &#39;[1]&#39;,     &#39;def m(x,y,*a) a end; m(7,7,1).inspect&#39;
assert_equal &#39;[1, 2]&#39;,  &#39;def m(x,y,*a) a end; m(7,7,1,2).inspect&#39;
assert_equal &#39;[]&#39;,      &#39;def m(x,y=7,*a) a end; m(7).inspect&#39;
assert_equal &#39;[]&#39;,      &#39;def m(x,y,z=7,*a) a end; m(7,7).inspect&#39;
assert_equal &#39;[]&#39;,      &#39;def m(x,y,z=7,*a) a end; m(7,7,7).inspect&#39;
assert_equal &#39;[]&#39;,      &#39;def m(x,y,z=7,zz=7,*a) a end; m(7,7,7).inspect&#39;
assert_equal &#39;[]&#39;,      &#39;def m(x,y,z=7,zz=7,*a) a end; m(7,7,7,7).inspect&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,z=7,zz=1,*a) zz end; m(7,7,7).inspect&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,z=7,zz=1,*a) zz end; m(7,7,7).inspect&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,z=7,zz=7,*a) zz end; m(7,7,7,1).inspect&#39;

# block argument
assert_equal &#39;Proc&#39;,    &#39;def m(&amp;block) block end; m{}.class&#39;
assert_equal &#39;nil&#39;,     &#39;def m(&amp;block) block end; m().inspect&#39;
assert_equal &#39;Proc&#39;,    &#39;def m(a,&amp;block) block end; m(7){}.class&#39;
assert_equal &#39;nil&#39;,     &#39;def m(a,&amp;block) block end; m(7).inspect&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,&amp;block) a end; m(1){}&#39;
assert_equal &#39;Proc&#39;,    &#39;def m(a,b=nil,&amp;block) block end; m(7){}.class&#39;
assert_equal &#39;nil&#39;,     &#39;def m(a,b=nil,&amp;block) block end; m(7).inspect&#39;
assert_equal &#39;Proc&#39;,    &#39;def m(a,b=nil,&amp;block) block end; m(7,7){}.class&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b=nil,&amp;block) b end; m(7,1){}&#39;
assert_equal &#39;Proc&#39;,    &#39;def m(a,b=nil,*c,&amp;block) block end; m(7){}.class&#39;
assert_equal &#39;nil&#39;,     &#39;def m(a,b=nil,*c,&amp;block) block end; m(7).inspect&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b=nil,*c,&amp;block) a end; m(1).inspect&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b=1,*c,&amp;block) b end; m(7).inspect&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b=7,*c,&amp;block) b end; m(7,1).inspect&#39;
assert_equal &#39;[1]&#39;,     &#39;def m(a,b=7,*c,&amp;block) c end; m(7,7,1).inspect&#39;

# splat
assert_equal &#39;1&#39;,       &#39;def m(a) a end; m(*[1])&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,a) a end; m(7,*[1])&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,a) a end; m(7,7,*[1])&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b) a end; m(*[1,7])&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b) b end; m(*[7,1])&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,a,b) b end; m(7,*[7,1])&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,a,b) b end; m(7,7,*[7,1])&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b,c) a end; m(*[1,7,7])&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b,c) b end; m(*[7,1,7])&#39;
assert_equal &#39;1&#39;,       &#39;def m(a,b,c) c end; m(*[7,7,1])&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,a,b,c) a end; m(7,*[1,7,7])&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,a,b,c) a end; m(7,7,*[1,7,7])&#39;

# hash argument
assert_equal &#39;1&#39;,       &#39;def m(h) h end; m(7=&gt;1)[7]&#39;
assert_equal &#39;1&#39;,       &#39;def m(h) h end; m(7=&gt;1).size&#39;
assert_equal &#39;1&#39;,       &#39;def m(h) h end; m(7=&gt;1, 8=&gt;7)[7]&#39;
assert_equal &#39;2&#39;,       &#39;def m(h) h end; m(7=&gt;1, 8=&gt;7).size&#39;
assert_equal &#39;1&#39;,       &#39;def m(h) h end; m(7=&gt;1, 8=&gt;7, 9=&gt;7)[7]&#39;
assert_equal &#39;3&#39;,       &#39;def m(h) h end; m(7=&gt;1, 8=&gt;7, 9=&gt;7).size&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,h) h end; m(7, 7=&gt;1)[7]&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,h) h end; m(7, 7=&gt;1, 8=&gt;7)[7]&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,h) h end; m(7, 7=&gt;1, 8=&gt;7, 9=&gt;7)[7]&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,h) h end; m(7,7, 7=&gt;1)[7]&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,h) h end; m(7,7, 7=&gt;1, 8=&gt;7)[7]&#39;
assert_equal &#39;1&#39;,       &#39;def m(x,y,h) h end; m(7,7, 7=&gt;1, 8=&gt;7, 9=&gt;7)[7]&#39;

# block argument
assert_equal &#39;1&#39;,       %q(def m(&amp;block) mm(&amp;block) end
                           def mm() yield 1 end
                           m {|a| a })
assert_equal &#39;1&#39;,       %q(def m(x,&amp;block) mm(x,&amp;block) end
                           def mm(x) yield 1 end
                           m(7) {|a| a })
assert_equal &#39;1&#39;,       %q(def m(x,y,&amp;block) mm(x,y,&amp;block) end
                           def mm(x,y) yield 1 end
                           m(7,7) {|a| a })

# recursive call
assert_equal &#39;1&#39;,       %q(def m(n) n == 0 ? 1 : m(n-1) end; m(5))

# instance method
assert_equal &#39;1&#39;,       %q(class C; def m() 1 end end;  C.new.m)
assert_equal &#39;1&#39;,       %q(class C; def m(a) a end end;  C.new.m(1))
assert_equal &#39;1&#39;,       %q(class C; def m(a = 1) a end end;  C.new.m)
assert_equal &#39;[1]&#39;,     %q(class C; def m(*a) a end end;  C.new.m(1).inspect)
assert_equal &#39;1&#39;,       %q( class C
                              def m() mm() end
                              def mm() 1 end
                            end
                            C.new.m )

# singleton method (const)
assert_equal &#39;1&#39;,       %q(class C; def C.m() 1 end end;  C.m)
assert_equal &#39;1&#39;,       %q(class C; def C.m(a) a end end;  C.m(1))
assert_equal &#39;1&#39;,       %q(class C; def C.m(a = 1) a end end;  C.m)
assert_equal &#39;[1]&#39;,     %q(class C; def C.m(*a) a end end;  C.m(1).inspect)
assert_equal &#39;1&#39;,       %q(class C; end; def C.m() 1 end;  C.m)
assert_equal &#39;1&#39;,       %q(class C; end; def C.m(a) a end;  C.m(1))
assert_equal &#39;1&#39;,       %q(class C; end; def C.m(a = 1) a end;  C.m)
assert_equal &#39;[1]&#39;,     %q(class C; end; def C.m(*a) a end;  C.m(1).inspect)
assert_equal &#39;1&#39;,       %q(class C; def m() 7 end end; def C.m() 1 end;  C.m)
assert_equal &#39;1&#39;,       %q( class C
                              def C.m() mm() end
                              def C.mm() 1 end
                            end
                            C.m )

# singleton method (lvar)
assert_equal &#39;1&#39;,       %q(obj = Object.new; def obj.m() 1 end;  obj.m)
assert_equal &#39;1&#39;,       %q(obj = Object.new; def obj.m(a) a end;  obj.m(1))
assert_equal &#39;1&#39;,       %q(obj = Object.new; def obj.m(a=1) a end;  obj.m)
assert_equal &#39;[1]&#39;,     %q(obj = Object.new; def obj.m(*a) a end;  obj.m(1))
assert_equal &#39;1&#39;,       %q(class C; def m() 7 end; end
                           obj = C.new
                           def obj.m() 1 end
                           obj.m)

# inheritance
assert_equal &#39;1&#39;,       %q(class A; def m(a) a end end
                           class B &lt; A; end
                           B.new.m(1))
assert_equal &#39;1&#39;,       %q(class A; end
                           class B &lt; A; def m(a) a end end
                           B.new.m(1))
assert_equal &#39;1&#39;,       %q(class A; def m(a) a end end
                           class B &lt; A; end
                           class C &lt; B; end
                           C.new.m(1))

# include
assert_equal &#39;1&#39;,       %q(class A; def m(a) a end end
                           module M; end
                           class B &lt; A; include M; end
                           B.new.m(1))
assert_equal &#39;1&#39;,       %q(class A; end
                           module M; def m(a) a end end
                           class B &lt; A; include M; end
                           B.new.m(1))

# alias
assert_equal &#39;1&#39;,       %q( def a() 1 end
                            alias m a
                            m() )
assert_equal &#39;1&#39;,       %q( class C
                              def a() 1 end
                              alias m a
                            end
                            C.new.m )
assert_equal &#39;1&#39;,       %q( class C
                              def a() 1 end
                              alias :m a
                            end
                            C.new.m )
assert_equal &#39;1&#39;,       %q( class C
                              def a() 1 end
                              alias m :a
                            end
                            C.new.m )
assert_equal &#39;1&#39;,       %q( class C
                              def a() 1 end
                              alias :m :a
                            end
                            C.new.m )
assert_equal &#39;1&#39;,       %q( class C
                              def a() 1 end
                              alias m a
                              undef a
                            end
                            C.new.m )

# undef
assert_equal &#39;1&#39;,       %q( class C
                              def m() end
                              undef m
                            end
                            begin C.new.m; rescue NoMethodError; 1 end )
assert_equal &#39;1&#39;,       %q( class A
                              def m() end
                            end
                            class C &lt; A
                              def m() end
                              undef m
                            end
                            begin C.new.m; rescue NoMethodError; 1 end )
assert_equal &#39;1&#39;,       %q( class A; def a() end end   # [yarv-dev:999]
                            class B &lt; A
                              def b() end
                              undef a, b
                            end
                            begin B.new.a; rescue NoMethodError; 1 end )
assert_equal &#39;1&#39;,       %q( class A; def a() end end   # [yarv-dev:999]
                            class B &lt; A
                              def b() end
                              undef a, b
                            end
                            begin B.new.b; rescue NoMethodError; 1 end )

assert_equal &#39;3&#39;,  %q{
  def m1
    1
  end
  alias m2 m1
  alias :&quot;#{&#39;m3&#39;}&quot; m1
  m1 + m2 + m3
}, &#39;[ruby-dev:32308]&#39;
assert_equal &#39;1&#39;, %q{
  def foobar
  end
  undef :&quot;foo#{:bar}&quot;
  1
}, &#39;[ruby-dev:32308]&#39;
assert_equal &#39;1&#39;, %q{
  def foobar
    1
  end
  alias :&quot;bar#{:baz}&quot; :&quot;foo#{:bar}&quot;
  barbaz
}, &#39;[ruby-dev:32308]&#39;

# private
assert_equal &#39;1&#39;,       %q( class C
                              def m() mm() end
                              def mm() 1 end
                              private :mm
                            end
                            C.new.m )
assert_equal &#39;1&#39;,       %q( class C
                              def m() 7 end
                              private :m
                            end
                            begin C.m; rescue NoMethodError; 1 end )
assert_equal &#39;1&#39;,       %q( class C
                              def C.m() mm() end
                              def C.mm() 1 end
                              private_class_method :mm
                            end
                            C.m )
assert_equal &#39;1&#39;,       %q( class C
                              def C.m() 7 end
                              private_class_method :m
                            end
                            begin C.m; rescue NoMethodError; 1 end )
assert_equal &#39;1&#39;,       %q( class C; def m() 1 end end
                            C.new.m   # cache
                            class C
                              alias mm m; private :mm
                            end
                            C.new.m
                            begin C.new.mm; 7; rescue NoMethodError; 1 end )

# nested method
assert_equal &#39;1&#39;,       %q( class C
                              def m
                                def mm() 1 end
                              end
                            end
                            C.new.m
                            C.new.mm )
assert_equal &#39;1&#39;,       %q( class C
                              def m
                                def mm() 1 end
                              end
                            end
                            instance_eval &quot;C.new.m; C.new.mm&quot; )

# method_missing
assert_equal &#39;:m&#39;,      %q( class C
                              def method_missing(mid, *args) mid end
                            end
                            C.new.m.inspect )
assert_equal &#39;:mm&#39;,     %q( class C
                              def method_missing(mid, *args) mid end
                            end
                            C.new.mm.inspect )
assert_equal &#39;[1, 2]&#39;,  %q( class C
                              def method_missing(mid, *args) args end
                            end
                            C.new.m(1,2).inspect )
assert_equal &#39;1&#39;,       %q( class C
                              def method_missing(mid, *args) yield 1 end
                            end
                            C.new.m {|a| a })
assert_equal &#39;nil&#39;,     %q( class C
                              def method_missing(mid, *args, &amp;block) block end
                            end
                            C.new.m.inspect )

# send
assert_equal &#39;1&#39;,       %q( class C; def m() 1 end end;
                            C.new.__send__(:m) )
assert_equal &#39;1&#39;,       %q( class C; def m() 1 end end;
                            C.new.send(:m) )
assert_equal &#39;1&#39;,       %q( class C; def m(a) a end end;
                            C.new.send(:m,1) )
assert_equal &#39;1&#39;,       %q( class C; def m(a,b) a end end;
                            C.new.send(:m,1,7) )
assert_equal &#39;1&#39;,       %q( class C; def m(x,a=1) a end end;
                            C.new.send(:m,7) )
assert_equal &#39;1&#39;,       %q( class C; def m(x,a=7) a end end;
                            C.new.send(:m,7,1) )
assert_equal &#39;[1, 2]&#39;,  %q( class C; def m(*a) a end end;
                            C.new.send(:m,1,2).inspect )
assert_equal &#39;1&#39;,       %q( class C; def m() 7 end; private :m end
                            begin C.new.public_send(:m); rescue NoMethodError; 1 end )
assert_equal &#39;1&#39;,       %q( class C; def m() 1 end; private :m end
                            C.new.send(:m) )

# with block
assert_equal &#39;[[:ok1, :foo], [:ok2, :foo, :bar]]&#39;,
%q{
  class C
    def [](a)
      $ary &lt;&lt; [yield, a]
    end
    def []=(a, b)
      $ary &lt;&lt; [yield, a, b]
    end
  end

  $ary = []
  C.new[:foo, &amp;lambda{:ok1}]
  C.new[:foo, &amp;lambda{:ok2}] = :bar
  $ary
}

# with
assert_equal &#39;[:ok1, [:ok2, 11]]&#39;, %q{
  class C
    def []
      $ary &lt;&lt; :ok1
      10
    end
    def []=(a)
      $ary &lt;&lt; [:ok2, a]
    end
  end
  $ary = []
  C.new[]+=1
  $ary
}

# splat and block arguments
assert_equal %q{[[[:x, :y, :z], NilClass], [[1, :x, :y, :z], NilClass], [[1, 2, :x, :y, :z], NilClass], [[:obj], NilClass], [[1, :obj], NilClass], [[1, 2, :obj], NilClass], [[], Proc], [[1], Proc], [[1, 2], Proc], [[], Proc], [[1], Proc], [[1, 2], Proc], [[:x, :y, :z], Proc], [[1, :x, :y, :z], Proc], [[1, 2, :x, :y, :z], Proc]]}, %q{
def m(*args, &amp;b)
  $result &lt;&lt; [args, b.class]
end
$result = []
ary = [:x, :y, :z]
obj = :obj
b = Proc.new{}

m(*ary)
m(1,*ary)
m(1,2,*ary)
m(*obj)
m(1,*obj)
m(1,2,*obj)
m(){}
m(1){}
m(1,2){}
m(&amp;b)
m(1,&amp;b)
m(1,2,&amp;b)
m(*ary,&amp;b)
m(1,*ary,&amp;b)
m(1,2,*ary,&amp;b)
$result
}

# aset and splat
assert_equal &#39;4&#39;, %q{class Foo;def []=(a,b,c,d);end;end;Foo.new[1,*a=[2,3]]=4}
assert_equal &#39;4&#39;, %q{class Foo;def []=(a,b,c,d);end;end;def m(&amp;blk)Foo.new[1,*a=[2,3],&amp;blk]=4;end;m{}}

# post test
assert_equal %q{[1, 2, :o1, :o2, [], 3, 4, NilClass, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4)}

assert_equal %q{[1, 2, 3, :o2, [], 4, 5, NilClass, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5)}

assert_equal %q{[1, 2, 3, 4, [], 5, 6, NilClass, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6)}

assert_equal %q{[1, 2, 3, 4, [5], 6, 7, NilClass, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7)}

assert_equal %q{[1, 2, 3, 4, [5, 6], 7, 8, NilClass, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7, 8)}

assert_equal %q{[1, 2, 3, 4, [5, 6, 7], 8, 9, NilClass, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7, 8, 9)}

assert_equal %q{[1, 2, 3, 4, [5, 6, 7, 8], 9, 10, NilClass, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)}

assert_equal %q{[1, 2, 3, 4, [5, 6, 7, 8, 9], 10, 11, NilClass, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)}

assert_equal %q{[1, 2, :o1, :o2, [], 3, 4, Proc, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4){}}

assert_equal %q{[1, 2, 3, :o2, [], 4, 5, Proc, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5){}}

assert_equal %q{[1, 2, 3, 4, [], 5, 6, Proc, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6){}}

assert_equal %q{[1, 2, 3, 4, [5], 6, 7, Proc, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7){}}

assert_equal %q{[1, 2, 3, 4, [5, 6], 7, 8, Proc, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7, 8){}}

assert_equal %q{[1, 2, 3, 4, [5, 6, 7], 8, 9, Proc, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7, 8, 9){}}

assert_equal %q{[1, 2, 3, 4, [5, 6, 7, 8], 9, 10, Proc, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7, 8, 9, 10){}}

assert_equal %q{[1, 2, 3, 4, [5, 6, 7, 8, 9], 10, 11, Proc, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2, &amp;b)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, b.class, x, y]
end
; m(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11){}}

assert_equal %q{[1, 2, :o1, :o2, [], 3, 4, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, x, y]
end
; m(1, 2, 3, 4)}

assert_equal %q{[1, 2, 3, :o2, [], 4, 5, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, x, y]
end
; m(1, 2, 3, 4, 5)}

assert_equal %q{[1, 2, 3, 4, [], 5, 6, nil, nil]}, %q{
def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2)
  x, y = :x, :y if $foo
  [m1, m2, o1, o2, r, p1, p2, x, y]
end
; m(1, 2, 3, 4, 5, 6)}


#
# super
#
=begin
# below programs are generated by this program:

BASE = &lt;&lt;EOS__
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; &lt;TEST&gt;; super; end; end
EOS__

tests = {
%q{
  def m
} =&gt; %q{
  C1.new.m
},
#
%q{
  def m a
} =&gt; %q{
  C1.new.m 1
},
%q{
  def m a
    a = :a
} =&gt; %q{
  C1.new.m 1
},
#
%q{
  def m a, o=:o
} =&gt; %q{
  C1.new.m 1
  C1.new.m 1, 2
},
%q{
  def m a, o=:o
    a = :a
} =&gt; %q{
  C1.new.m 1
  C1.new.m 1, 2
},
%q{
  def m a, o=:o
    o = :x
} =&gt; %q{
  C1.new.m 1
  C1.new.m 1, 2
},
#
%q{
  def m a, *r
} =&gt; %q{
  C1.new.m 1
  C1.new.m 1, 2
  C1.new.m 1, 2, 3
},
%q{
  def m a, *r
    r = [:x, :y]
} =&gt; %q{
  C1.new.m 1
  C1.new.m 1, 2
  C1.new.m 1, 2, 3
},
#
%q{
  def m a, o=:o, *r
} =&gt; %q{
  C1.new.m 1
  C1.new.m 1, 2
  C1.new.m 1, 2, 3
  C1.new.m 1, 2, 3, 4
},
#
%q{
  def m a, o=:o, *r, &amp;b
} =&gt; %q{
  C1.new.m 1
  C1.new.m 1, 2
  C1.new.m 1, 2, 3
  C1.new.m 1, 2, 3, 4
  C1.new.m(1){}
  C1.new.m(1, 2){}
  C1.new.m(1, 2, 3){}
  C1.new.m(1, 2, 3, 4){}
},
#
&quot;def m(m1, m2, o1=:o1, o2=:o2, p1, p2)&quot; =&gt;
%q{
C1.new.m(1,2,3,4)
C1.new.m(1,2,3,4,5)
C1.new.m(1,2,3,4,5,6)
},
#
&quot;def m(m1, m2, *r, p1, p2)&quot; =&gt;
%q{
C1.new.m(1,2,3,4)
C1.new.m(1,2,3,4,5)
C1.new.m(1,2,3,4,5,6)
C1.new.m(1,2,3,4,5,6,7)
C1.new.m(1,2,3,4,5,6,7,8)
},
#
&quot;def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2)&quot; =&gt;
%q{
C1.new.m(1,2,3,4)
C1.new.m(1,2,3,4,5)
C1.new.m(1,2,3,4,5,6)
C1.new.m(1,2,3,4,5,6,7)
C1.new.m(1,2,3,4,5,6,7,8)
C1.new.m(1,2,3,4,5,6,7,8,9)
},

###
}


tests.each{|setup, methods| setup = setup.dup; setup.strip!
  setup = BASE.gsub(/&lt;TEST&gt;/){setup}
  methods.split(/\n/).each{|m| m = m.dup; m.strip!
    next if m.empty?
    expr = &quot;#{setup}; #{m}&quot;
    result = eval(expr)
    puts &quot;assert_equal %q{#{result.inspect}}, %q{\n#{expr}}&quot;
    puts
  }
}

=end

assert_equal %q{[:C0_m, [1, 2, :o1, :o2, 3, 4]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, p1, p2); super; end; end
; C1.new.m(1,2,3,4)}

assert_equal %q{[:C0_m, [1, 2, 3, :o2, 4, 5]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5, 6]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5,6)}

assert_equal %q{[:C0_m, [1, :o]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [1, 2]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r; super; end; end
; C1.new.m 1, 2}

assert_equal %q{[:C0_m, [1, 2, 3]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r; super; end; end
; C1.new.m 1, 2, 3}

assert_equal %q{[:C0_m, [1, 2, 3, 4]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r; super; end; end
; C1.new.m 1, 2, 3, 4}

assert_equal %q{[:C0_m, [:a]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a
    a = :a; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [1, 2, 3, 4]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5, 6]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5,6)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5, 6, 7]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5,6,7)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5, 6, 7, 8]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5,6,7,8)}

assert_equal %q{[:C0_m, [1, :o]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r, &amp;b; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [1, 2]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r, &amp;b; super; end; end
; C1.new.m 1, 2}

assert_equal %q{[:C0_m, [1, 2, 3]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r, &amp;b; super; end; end
; C1.new.m 1, 2, 3}

assert_equal %q{[:C0_m, [1, 2, 3, 4]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r, &amp;b; super; end; end
; C1.new.m 1, 2, 3, 4}

assert_equal %q{[:C0_m, [1, :o]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r, &amp;b; super; end; end
; C1.new.m(1){}}

assert_equal %q{[:C0_m, [1, 2]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r, &amp;b; super; end; end
; C1.new.m(1, 2){}}

assert_equal %q{[:C0_m, [1, 2, 3]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r, &amp;b; super; end; end
; C1.new.m(1, 2, 3){}}

assert_equal %q{[:C0_m, [1, 2, 3, 4]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o, *r, &amp;b; super; end; end
; C1.new.m(1, 2, 3, 4){}}

assert_equal %q{[:C0_m, [1, :x]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o
    o = :x; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [1, :x]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o
    o = :x; super; end; end
; C1.new.m 1, 2}

assert_equal %q{[:C0_m, [:a, :o]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o
    a = :a; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [:a, 2]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o
    a = :a; super; end; end
; C1.new.m 1, 2}

assert_equal %q{[:C0_m, [1]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [1, :x, :y]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, *r
    r = [:x, :y]; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [1, :x, :y]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, *r
    r = [:x, :y]; super; end; end
; C1.new.m 1, 2}

assert_equal %q{[:C0_m, [1, :x, :y]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, *r
    r = [:x, :y]; super; end; end
; C1.new.m 1, 2, 3}

assert_equal %q{[:C0_m, [1, 2, :o1, :o2, 3, 4]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4)}

assert_equal %q{[:C0_m, [1, 2, 3, :o2, 4, 5]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5, 6]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5,6)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5, 6, 7]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5,6,7)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5, 6, 7, 8]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5,6,7,8)}

assert_equal %q{[:C0_m, [1, 2, 3, 4, 5, 6, 7, 8, 9]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m(m1, m2, o1=:o1, o2=:o2, *r, p1, p2); super; end; end
; C1.new.m(1,2,3,4,5,6,7,8,9)}

assert_equal %q{[:C0_m, [1]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, *r; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [1, 2]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, *r; super; end; end
; C1.new.m 1, 2}

assert_equal %q{[:C0_m, [1, 2, 3]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, *r; super; end; end
; C1.new.m 1, 2, 3}

assert_equal %q{[:C0_m, []]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m; super; end; end
; C1.new.m}

assert_equal %q{[:C0_m, [1, :o]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o; super; end; end
; C1.new.m 1}

assert_equal %q{[:C0_m, [1, 2]]}, %q{
class C0; def m *args; [:C0_m, args]; end; end
class C1 &lt; C0; def m a, o=:o; super; end; end
; C1.new.m 1, 2}

assert_equal &#39;ok&#39;, %q{
  class C
    def x=(n)
    end
    def m
      self.x = :ok
    end
  end
  C.new.m
}

assert_equal &#39;ok&#39;, %q{
  proc{
    $SAFE = 1
    class C
      def m
        :ok
      end
    end
  }.call
  C.new.m
}, &#39;[ruby-core:11998]&#39;

assert_equal &#39;ok&#39;, %q{
  class B
    def m() :fail end
  end
  class C &lt; B
    undef m
    begin
      remove_method :m
    rescue NameError
    end
  end
  begin
    C.new.m
  rescue NameError
    :ok
  end
}, &#39;[ruby-dev:31816], [ruby-dev:31817]&#39;

assert_normal_exit %q{
  begin
    Process.setrlimit(Process::RLIMIT_STACK, 4_206_592)
    # FreeBSD SEGVs this less than 4M + 12K bytes.
  rescue Exception
    exit
  end
  class C
    attr &quot;a&quot; * (10*1024*1024)
  end
}, &#39;[ruby-dev:31818]&#39;

assert_equal &#39;ok&#39;, %q{
  class Module
    def define_method2(name, &amp;block)
      define_method(name, &amp;block)
    end
  end
  class C
    define_method2(:m) {|x, y| :fail }
  end
  begin
    C.new.m([1,2])
  rescue ArgumentError
    :ok
  end
}

assert_not_match /method_missing/, %q{
  STDERR.reopen(STDOUT)
  variable_or_mehtod_not_exist
}

assert_equal &#39;[false, false, false, false, true, true]&#39;, %q{
  class C
    define_method(:foo) {
      block_given?
    }
  end

  C.new.foo {}

  class D
    def foo
      D.module_eval{
        define_method(:m1){
          block_given?
        }
      }
    end
    def bar
      D.module_eval{
        define_method(:m2){
          block_given?
        }
      }
    end
  end

  D.new.foo
  D.new.bar{}
  [C.new.foo, C.new.foo{}, D.new.m1, D.new.m1{}, D.new.m2, D.new.m2{}]
}, &#39;[ruby-core:14813]&#39;

assert_equal &#39;ok&#39;, %q{
  class Foo
    define_method(:foo) do |&amp;b|
      b.call
    end
  end
  Foo.new.foo do
    break :ok
  end
}, &#39;[ruby-dev:36028]&#39;

assert_equal &#39;[1, 2, [3, 4]]&#39;, %q{
  def regular(a, b, *c)
    [a, b, c]
  end
  regular(*[], 1, *[], *[2, 3], *[], 4)
}, &#39;[ruby-core:19413]&#39;

assert_equal &#39;[1, [:foo, 3, 4, :foo]]&#39;, %q{
  def regular(a, *b)
    [a, b]
  end
  a = b = [:foo]
  regular(1, *a, *[3, 4], *b)
}

assert_equal &#39;[&quot;B&quot;, &quot;A&quot;]&#39;, %q{
  class A
    def m
      &#39;A&#39;
    end
  end

  class B &lt; A
    define_method(:m) do
      [&#39;B&#39;, super()]
    end
  end

  class C &lt; B
  end

  C.new.m
}

assert_equal &#39;ok&#39;, %q{
  module Foo
    def foo
      begin
        super
      rescue NoMethodError
        :ok
      end
    end
    module_function :foo
  end
  Foo.foo
}, &#39;[ruby-dev:37587]&#39;

assert_equal &#39;Object#foo&#39;, %q{
  class Object
    def self.foo
      &quot;Object.foo&quot;
    end
    def foo
      &quot;Object#foo&quot;
    end
  end

  module Foo
    def foo
      begin
        super
      rescue NoMethodError
        :ok
      end
    end
    module_function :foo
  end
  Foo.foo
}, &#39;[ruby-dev:37587]&#39;

assert_normal_exit %q{
  class BasicObject
    remove_method :method_missing
  end
  begin
    &quot;a&quot;.lalala!
  rescue NoMethodError =&gt; e
    e.message == &quot;undefined method `lalala!&#39; for \&quot;a\&quot;:String&quot; ? :ok : :ng
  end
}, &#39;[ruby-core:22298]&#39;

assert_equal &#39;ok&#39;, %q{
  &quot;hello&quot;[0] ||= &quot;H&quot;
  &quot;ok&quot;
}

assert_equal &#39;ok&#39;, %q{
  &quot;hello&quot;[0, 1] ||= &quot;H&quot;
  &quot;ok&quot;
}

assert_equal &#39;ok&#39;, %q{
  class C
    define_method(:foo) do
      C.class_eval { remove_method(:foo) }
      super()
    end
  end
  begin
    C.new.foo
  rescue NoMethodError
    &#39;ok&#39;
  end
}
assert_equal &#39;ok&#39;, %q{
  [0][0, &amp;proc{}] += 21
  &#39;ok&#39;
}, &#39;[ruby-core:30534]&#39;

# should not cache when splat
assert_equal &#39;ok&#39;, %q{
  class C
    attr_reader :a
    def initialize
      @a = 1
    end
  end

  def m *args
    C.new.a(*args)
  end

  m()
  begin
    m(1)
  rescue ArgumentError
    &#39;ok&#39;
  end
}

assert_equal &#39;DC&#39;, %q{
  $result = []

  class C
    def foo *args
      $result &lt;&lt; &#39;C&#39;
    end
  end
  class D
    def foo *args
      $result &lt;&lt; &#39;D&#39;
    end
  end

  o1 = $o1 = C.new
  o2 = $o2 = D.new

  args = Object.new
  def args.to_a
    test1 $o2, nil
    []
  end
  def test1 o, args
    o.foo(*args)
  end
  test1 o1, args
  $result.join
}

assert_equal &#39;DC&#39;, %q{
  $result = []

  class C
    def foo *args
      $result &lt;&lt; &#39;C&#39;
    end
  end
  class D
    def foo *args
      $result &lt;&lt; &#39;D&#39;
    end
  end

  o1 = $o1 = C.new
  o2 = $o2 = D.new

  block = Object.new
  def block.to_proc
    test2 $o2, %w(a, b, c), nil
    Proc.new{}
  end
  def test2 o, args, block
    o.foo(*args, &amp;block)
  end
  test2 o1, [], block
  $result.join
}
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  

</body>
</html>

