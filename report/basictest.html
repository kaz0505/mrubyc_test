<html>
<head>
  <meta charset='utf-8' />
  <title>mruby/c basictest report</title>
</head>
<body>

  
    <div>
      <h2>test_condition.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;condition&quot;

$x = &#39;0&#39;;

$x == $x &amp;&amp; test_ok(true)
$x != $x &amp;&amp; test_ok(false)
$x == $x || test_ok(false)
$x != $x || test_ok(true)
</pre>
      <pre>-- condition
ok 1
ok 2
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_if_unless.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;if/unless&quot;;

$x = &#39;test&#39;;
test_ok(if $x == $x then true else false end)
$bad = false
unless $x == $x
  $bad = true
end
test_ok(!$bad)
test_ok(unless $x != $x then true else false end)

</pre>
      <pre>-- if/unless
ok 1
no method(!)!
not ok if/unless 2
ok 3
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_case.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;case&quot;

case 5
when 1, 2, 3, 4, 6, 7, 8
  test_ok(false)
when 5
  test_ok(true)
end

case 5
when 5
  test_ok(true)
when 1..10
  test_ok(false)
end

case 5
when 1..10
  test_ok(true)
else
  test_ok(false)
end

case 5
when 5
  test_ok(true)
else
  test_ok(false)
end

case &quot;foobar&quot;
when /^f.*r$/
  test_ok(true)
else
  test_ok(false)
end

</pre>
      <pre>-- case
no method(===)!
not ok case 1
no method(===)!
ok 2
no method(===)!
ok 3
no method(===)!
ok 4
Skip OP=42
Skip OP=13
no method(compile)!
no method(===)!
ok 5
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_multiple_assignment.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;multiple assignment&quot;

# multiple asignment
a, b = 1, 2
test_ok(a == 1 &amp;&amp; b == 2)

a, b = b, a
test_ok(a == 2 &amp;&amp; b == 1)

a, = 1,2
test_ok(a == 1)

a, *b = 1, 2, 3
test_ok(a == 1 &amp;&amp; b == [2, 3])

a, (b, c), d = 1, [2, 3], 4
test_ok(a == 1 &amp;&amp; b == 2 &amp;&amp; c == 3 &amp;&amp; d == 4)

*a = 1, 2, 3
test_ok(a == [1, 2, 3])

*a = 4
test_ok(a == [4])

*a = nil
test_ok(a == [nil])

</pre>
      <pre>-- multiple assignment
ok 1
ok 2
ok 3
ok 4
Skip OP=3A
Skip OP=3A
Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_const.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;const&quot;
TEST1 = 1
TEST2 = 2

module Const
  TEST3 = 3
  TEST4 = 4
end

module Const2
  TEST3 = 6
  TEST4 = 8
end

include Const

test_ok([TEST1,TEST2,TEST3,TEST4] == [1,2,3,4])

include Const2
STDERR.print &quot;intentionally redefines TEST3, TEST4\n&quot; if $VERBOSE
test_ok([TEST1,TEST2,TEST3,TEST4] == [1,2,6,8])


test_ok((String &lt;=&gt; Object) == -1)
test_ok((Object &lt;=&gt; String) == 1)
test_ok((Array &lt;=&gt; String) == nil)


</pre>
      <pre>-- const
Skip OP=44
Skip OP=45
Skip OP=44
Skip OP=45
no method(include)!
not ok const 1
no method(include)!
Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_call.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;call&quot;
def aaa(a, b=100, *rest)
  res = [a, b]
  res += rest if rest
  return res
end

# not enough argument
begin
  aaa()				# need at least 1 arg
  test_ok(false)
rescue
  test_ok(true)
end

begin
  aaa				# no arg given (exception raised)
  test_ok(false)
rescue
  test_ok(true)
end

test_ok(aaa(1) == [1, 100])
test_ok(aaa(1, 2) == [1, 2])
test_ok(aaa(1, 2, 3, 4) == [1, 2, 3, 4])
test_ok(aaa(1, *[2, 3, 4]) == [1, 2, 3, 4])


</pre>
      <pre>-- call
Skip OP=1A
Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_proc.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;proc&quot;
$proc = Proc.new{|i| i}
test_ok($proc.call(2) == 2)
test_ok($proc.call(3) == 3)

$proc = Proc.new{|i| i*2}
test_ok($proc.call(2) == 4)
test_ok($proc.call(3) == 6)

Proc.new{
  iii=5				# nested local variable
  $proc = Proc.new{|i|
    iii = i
  }
  $proc2 = Proc.new {
    $x = iii			# nested variables shared by procs
  }
  # scope of nested variables
  test_ok(defined?(iii))
}.call
test_ok(!defined?(iii))		# out of scope

loop{iii=5; test_ok(eval(&quot;defined? iii&quot;)); break}
loop {
  iii = 10
  def dyna_var_check
    loop {
      test_ok(!defined?(iii))
      break
    }
  end
  dyna_var_check
  break
}
$x=0
$proc.call(5)
$proc2.call
test_ok($x == 5)


</pre>
      <pre>-- proc
Skip OP=21
no method(call)!
Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_float.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;float&quot;
test_ok(2.6.floor == 2)
test_ok((-2.6).floor == -3)
test_ok(2.6.ceil == 3)
test_ok((-2.6).ceil == -2)
test_ok(2.6.truncate == 2)
test_ok((-2.6).truncate == -2)
test_ok(2.6.round == 3)
test_ok((-2.4).truncate == -2)
test_ok((13.4 % 1 - 0.4).abs &lt; 0.0001)
nan = 0.0/0
def nan_test(x,y)
  test_ok(x != y)
  test_ok((x &lt; y) == false)
  test_ok((x &gt; y) == false)
  test_ok((x &lt;= y) == false)
  test_ok((x &gt;= y) == false)
end
nan_test(nan, nan)
nan_test(nan, 0)
nan_test(nan, 1)
nan_test(nan, -1)
nan_test(nan, 1000)
nan_test(nan, -1000)
nan_test(nan, 1_000_000_000_000)
nan_test(nan, -1_000_000_000_000)
nan_test(nan, 100.0);
nan_test(nan, -100.0);
nan_test(nan, 0.001);
nan_test(nan, -0.001);
nan_test(nan, 1.0/0);
nan_test(nan, -1.0/0);

#s = &quot;3.7517675036461267e+17&quot;
#test_ok(s == sprintf(&quot;%.16e&quot;, s.to_f))
f = 3.7517675036461267e+17
test_ok(f == sprintf(&quot;%.16e&quot;, f).to_f)



</pre>
      <pre>Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_variable.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;variable&quot;
test_ok($$.instance_of?(Integer))

# read-only variable
begin
  $$ = 5
  test_ok false
rescue NameError
  test_ok true
end

foobar = &quot;foobar&quot;
$_ = foobar
test_ok($_ == foobar)

class Gods
  @@rule = &quot;Uranus&quot;		# private to Gods
  def ruler0
    @@rule
  end

  def self.ruler1		# &lt;= per method definition style
    @@rule
  end
  class &lt;&lt; self			# &lt;= multiple method definition style
    def ruler2
      @@rule
    end
  end
end

module Olympians
  @@rule =&quot;Zeus&quot;
  def ruler3
    @@rule
  end
end

class Titans &lt; Gods
  @@rule = &quot;Cronus&quot;		# do not affect @@rule in Gods
  include Olympians
  def ruler4
    @@rule
  end
end

test_ok(Gods.new.ruler0 == &quot;Cronus&quot;)
test_ok(Gods.ruler1 == &quot;Cronus&quot;)
test_ok(Gods.ruler2 == &quot;Cronus&quot;)
test_ok(Titans.ruler1 == &quot;Cronus&quot;)
test_ok(Titans.ruler2 == &quot;Cronus&quot;)
atlas = Titans.new
test_ok(atlas.ruler0 == &quot;Cronus&quot;)
test_ok(atlas.ruler3 == &quot;Zeus&quot;)
test_ok(atlas.ruler4 == &quot;Cronus&quot;)


</pre>
      <pre>Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_hash.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;hash&quot;
$x = {1=&gt;2, 2=&gt;4, 3=&gt;6}

test_ok($x[1] == 2)

test_ok(begin
     for k,v in $x
       raise if k*2 != v
     end
     true
   rescue
     false
   end)

test_ok($x.length == 3)
test_ok($x.has_key?(1))
test_ok($x.has_value?(4))
test_ok($x.values_at(2,3) == [4,6])
test_ok($x == {1=&gt;2, 2=&gt;4, 3=&gt;6})

$z = $x.keys.sort.join(&quot;:&quot;)
test_ok($z == &quot;1:2:3&quot;)

$z = $x.values.sort.join(&quot;:&quot;)
test_ok($z == &quot;2:4:6&quot;)
test_ok($x == $x)

$x.shift
test_ok($x.length == 2)

$z = [1,2]
$x[$z] = 256
test_ok($x[$z] == 256)

$x = Hash.new(0)
$x[1] = 1
test_ok($x[1] == 1)
test_ok($x[2] == 0)

$x = Hash.new([])
test_ok($x[22] == [])
test_ok($x[22].equal?($x[22]))

$x = Hash.new{[]}
test_ok($x[22] == [])
test_ok(!$x[22].equal?($x[22]))

$x = Hash.new{|h,k| $z = k; h[k] = k*2}
$z = 0
test_ok($x[22] == 44)
test_ok($z == 22)
$z = 0
test_ok($x[22] == 44)
test_ok($z == 0)
$x.default = 5
test_ok($x[23] == 5)

$x = Hash.new
def $x.default(k)
  $z = k
  self[k] = k*2
end
$z = 0
test_ok($x[22] == 44)
test_ok($z == 22)
$z = 0
test_ok($x[22] == 44)
test_ok($z == 0)


</pre>
      <pre>-- hash
Skip OP=3F
no method([])!
not ok hash 1
Skip OP=1A
Skip OP=21
Skip OP=1C
ok 2
no method(length)!
Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_while_until.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;while/until&quot;;

while_tmp = &quot;while_tmp.#{$$}&quot;
tmp = open(while_tmp, &quot;w&quot;)
tmp.print &quot;tvi925\n&quot;;
tmp.print &quot;tvi920\n&quot;;
tmp.print &quot;vt100\n&quot;;
tmp.print &quot;Amiga\n&quot;;
tmp.print &quot;paper\n&quot;;
tmp.close

# test break

tmp = open(while_tmp, &quot;r&quot;)
test_ok(tmp.kind_of?(File))

while line = tmp.gets()
  break if /vt100/ =~ line
end

test_ok(!tmp.eof? &amp;&amp; /vt100/ =~ line)
tmp.close

# test next
$bad = false
tmp = open(while_tmp, &quot;r&quot;)
while line = tmp.gets()
  next if /vt100/ =~ line
  $bad = 1 if /vt100/ =~ line
end
test_ok(!(!tmp.eof? || /vt100/ =~ line || $bad))
tmp.close

# test redo
$bad = false
tmp = open(while_tmp, &quot;r&quot;)
while line = tmp.gets()
  lastline = line
  line = line.gsub(/vt100/, &#39;VT100&#39;)
  if lastline != line
    line.gsub!(&#39;VT100&#39;, &#39;Vt100&#39;)
    redo
  end
  $bad = 1 if /vt100/ =~ line
  $bad = 1 if /VT100/ =~ line
end
test_ok(tmp.eof? &amp;&amp; !$bad)
tmp.close

sum=0
for i in 1..10
  sum += i
  i -= 1
  if i &gt; 0
    redo
  end
end
test_ok(sum == 220)

# test interval
$bad = false
tmp = open(while_tmp, &quot;r&quot;)
while line = tmp.gets()
  break if 3
  case line
  when /vt100/, /Amiga/, /paper/
    $bad = true
  end
end
test_ok(!$bad)
tmp.close

File.unlink while_tmp or `/bin/rm -f &quot;#{while_tmp}&quot;`
test_ok(!File.exist?(while_tmp))

i = 0
until i&gt;4
  i+=1
end
test_ok(i&gt;4)

</pre>
      <pre>Segmentation fault (core dumped)
[New LWP 36955]
Core was generated by `/home/yhara/work/mrubyc_test/mrubyc/sample_c/mrubyc test/mrubytest.mrb&#39;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004032f0 in ?? ()
#0  0x00000000004032f0 in ?? ()
#1  0x00007fff8489eb40 in ?? ()
#2  0x000000000060a3e2 in ?? ()
#3  0x008081b78489eb40 in ?? ()
#4  0x000000000060a3c0 in ?? ()
#5  0x0000000200000001 in ?? ()
#6  0x0000000100000003 in ?? ()
#7  0x0080000a0060a210 in ?? ()
#8  0x0000000000000000 in ?? ()
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_array.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;array&quot;
test_ok([1, 2] + [3, 4] == [1, 2, 3, 4])
test_ok([1, 2] * 2 == [1, 2, 1, 2])
test_ok([1, 2] * &quot;:&quot; == &quot;1:2&quot;)

test_ok([1, 2].hash == [1, 2].hash)

test_ok([1,2,3] &amp; [2,3,4] == [2,3])
test_ok([1,2,3] | [2,3,4] == [1,2,3,4])
test_ok([1,2,3] - [2,3] == [1])

$x = [0, 1, 2, 3, 4, 5]
test_ok($x[2] == 2)
test_ok($x[1..3] == [1, 2, 3])
test_ok($x[1,3] == [1, 2, 3])

$x[0, 2] = 10
test_ok($x[0] == 10 &amp;&amp; $x[1] == 2)

$x[0, 0] = -1
test_ok($x[0] == -1 &amp;&amp; $x[1] == 10)

$x[-1, 1] = 20
test_ok($x[-1] == 20 &amp;&amp; $x.pop == 20)

# array and/or
test_ok(([1,2,3]&amp;[2,4,6]) == [2])
test_ok(([1,2,3]|[2,4,6]) == [1,2,3,4,6])

# compact
$x = [nil, 1, nil, nil, 5, nil, nil]
$x.compact!
test_ok($x == [1, 5])

# uniq
$x = [1, 1, 4, 2, 5, 4, 5, 1, 2]
$x.uniq!
test_ok($x == [1, 4, 2, 5])

# empty?
test_ok(!$x.empty?)
$x = []
test_ok($x.empty?)

# sort
$x = [&quot;it&quot;, &quot;came&quot;, &quot;to&quot;, &quot;pass&quot;, &quot;that&quot;, &quot;...&quot;]
$x = $x.sort.join(&quot; &quot;)
test_ok($x == &quot;... came it pass that to&quot;)
$x = [2,5,3,1,7]
$x.sort!{|a,b| a&lt;=&gt;b}		# sort with condition
test_ok($x == [1,2,3,5,7])
$x.sort!{|a,b| b-a}		# reverse sort
test_ok($x == [7,5,3,2,1])

# split test
$x = &quot;The Book of Mormon&quot;
test_ok($x.split(//).reverse!.join == $x.reverse)
test_ok($x.reverse == $x.reverse!)
test_ok(&quot;1 byte string&quot;.split(//).reverse.join(&quot;:&quot;) == &quot;g:n:i:r:t:s: :e:t:y:b: :1&quot;)
$x = &quot;a b c  d&quot;
test_ok($x.split == [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
test_ok($x.split(&#39; &#39;) == [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
test_ok(defined? &quot;a&quot;.chomp)
test_ok(&quot;abc&quot;.scan(/./) == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
test_ok(&quot;1a2b3c&quot;.scan(/(\d.)/) == [[&quot;1a&quot;], [&quot;2b&quot;], [&quot;3c&quot;]])
# non-greedy match
test_ok(&quot;a=12;b=22&quot;.scan(/(.*?)=(\d*);?/) == [[&quot;a&quot;, &quot;12&quot;], [&quot;b&quot;, &quot;22&quot;]])

$x = [1]
test_ok(($x * 5).join(&quot;:&quot;) == &#39;1:1:1:1:1&#39;)
test_ok(($x * 1).join(&quot;:&quot;) == &#39;1&#39;)
test_ok(($x * 0).join(&quot;:&quot;) == &#39;&#39;)

*$x = *(1..7).to_a
test_ok($x.size == 7)
test_ok($x == [1, 2, 3, 4, 5, 6, 7])

$x = [1,2,3]
$x[1,0] = $x
test_ok($x == [1,1,2,3,2,3])

$x = [1,2,3]
$x[-1,0] = $x
test_ok($x == [1,2,1,2,3,3])

$x = [1,2,3]
$x.concat($x)
test_ok($x == [1,2,3,1,2,3])


</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_string.out</h2>
      <pre style='float: left; width: 50%'>#test_check &quot;string &amp; char&quot;
#
#test_ok(&quot;abcd&quot; == &quot;abcd&quot;)
#test_ok(&quot;abcd&quot; =~ /abcd/)
#test_ok(&quot;abcd&quot; === &quot;abcd&quot;)
## compile time string concatenation
#test_ok(&quot;ab&quot; &quot;cd&quot; == &quot;abcd&quot;)
#test_ok(&quot;#{22}aa&quot; &quot;cd#{44}&quot; == &quot;22aacd44&quot;)
#test_ok(&quot;#{22}aa&quot; &quot;cd#{44}&quot; &quot;55&quot; &quot;#{66}&quot; == &quot;22aacd445566&quot;)
#test_ok(&quot;abc&quot; !~ /^$/)
#test_ok(&quot;abc\n&quot; !~ /^$/)
#test_ok(&quot;abc&quot; !~ /^d*$/)
#test_ok((&quot;abc&quot; =~ /d*$/) == 3)
#test_ok(&quot;&quot; =~ /^$/)
#test_ok(&quot;\n&quot; =~ /^$/)
#test_ok(&quot;a\n\n&quot; =~ /^$/)
#test_ok(&quot;abcabc&quot; =~ /.*a/ &amp;&amp; $&amp; == &quot;abca&quot;)
#test_ok(&quot;abcabc&quot; =~ /.*c/ &amp;&amp; $&amp; == &quot;abcabc&quot;)
#test_ok(&quot;abcabc&quot; =~ /.*?a/ &amp;&amp; $&amp; == &quot;a&quot;)
#test_ok(&quot;abcabc&quot; =~ /.*?c/ &amp;&amp; $&amp; == &quot;abc&quot;)
#test_ok(/(.|\n)*?\n(b|\n)/ =~ &quot;a\nb\n\n&quot; &amp;&amp; $&amp; == &quot;a\nb&quot;)
#
#test_ok(/^(ab+)+b/ =~ &quot;ababb&quot; &amp;&amp; $&amp; == &quot;ababb&quot;)
#test_ok(/^(?:ab+)+b/ =~ &quot;ababb&quot; &amp;&amp; $&amp; == &quot;ababb&quot;)
#test_ok(/^(ab+)+/ =~ &quot;ababb&quot; &amp;&amp; $&amp; == &quot;ababb&quot;)
#test_ok(/^(?:ab+)+/ =~ &quot;ababb&quot; &amp;&amp; $&amp; == &quot;ababb&quot;)
#
#test_ok(/(\s+\d+){2}/ =~ &quot; 1 2&quot; &amp;&amp; $&amp; == &quot; 1 2&quot;)
#test_ok(/(?:\s+\d+){2}/ =~ &quot; 1 2&quot; &amp;&amp; $&amp; == &quot; 1 2&quot;)
#
#$x = &lt;&lt;END;
#ABCD
#ABCD
#END
#$x.gsub!(/((.|\n)*?)B((.|\n)*?)D/, &#39;\1\3&#39;)
#test_ok($x == &quot;AC\nAC\n&quot;)
#
#test_ok(&quot;foobar&quot; =~ /foo(?=(bar)|(baz))/)
#test_ok(&quot;foobaz&quot; =~ /foo(?=(bar)|(baz))/)
#
#$foo = &quot;abc&quot;
#test_ok(&quot;#$foo = abc&quot; == &quot;abc = abc&quot;)
#test_ok(&quot;#{$foo} = abc&quot; == &quot;abc = abc&quot;)
#
#foo = &quot;abc&quot;
#test_ok(&quot;#{foo} = abc&quot; == &quot;abc = abc&quot;)
#
#test_ok(&#39;-&#39; * 5 == &#39;-----&#39;)
#test_ok(&#39;-&#39; * 1 == &#39;-&#39;)
#test_ok(&#39;-&#39; * 0 == &#39;&#39;)
#
#foo = &#39;-&#39;
#test_ok(foo * 5 == &#39;-----&#39;)
#test_ok(foo * 1 == &#39;-&#39;)
#test_ok(foo * 0 == &#39;&#39;)
#
#$x = &quot;a.gif&quot;
#test_ok($x.sub(/.*\.([^\.]+)$/, &#39;\1&#39;) == &quot;gif&quot;)
#test_ok($x.sub(/.*\.([^\.]+)$/, &#39;b.\1&#39;) == &quot;b.gif&quot;)
#test_ok($x.sub(/.*\.([^\.]+)$/, &#39;\2&#39;) == &quot;&quot;)
#test_ok($x.sub(/.*\.([^\.]+)$/, &#39;a\2b&#39;) == &quot;ab&quot;)
#test_ok($x.sub(/.*\.([^\.]+)$/, &#39;&lt;\&amp;&gt;&#39;) == &quot;&lt;a.gif&gt;&quot;)
#
## character constants(assumes ASCII)
#test_ok(&quot;a&quot;[0] == ?a)
#test_ok(?a == ?a)
#test_ok(?\C-a == &quot;\1&quot;)
#test_ok(?\M-a == &quot;\341&quot;)
#test_ok(?\M-\C-a == &quot;\201&quot;)
#test_ok(&quot;a&quot;.upcase![0] == ?A)
#test_ok(&quot;A&quot;.downcase![0] == ?a)
#test_ok(&quot;abc&quot;.tr!(&quot;a-z&quot;, &quot;A-Z&quot;) == &quot;ABC&quot;)
#test_ok(&quot;aabbcccc&quot;.tr_s!(&quot;a-z&quot;, &quot;A-Z&quot;) == &quot;ABC&quot;)
#test_ok(&quot;abcc&quot;.squeeze!(&quot;a-z&quot;) == &quot;abc&quot;)
#test_ok(&quot;abcd&quot;.delete!(&quot;bc&quot;) == &quot;ad&quot;)
#
#$x = &quot;abcdef&quot;
#$y = [ ?a, ?b, ?c, ?d, ?e, ?f ]
#$bad = false
#$x.each_byte {|i|
#  if i.chr != $y.shift
#    $bad = true
#    break
#  end
#}
#test_ok(!$bad)
#
#s = &quot;a string&quot;
#s[0..s.size]=&quot;another string&quot;
#test_ok(s == &quot;another string&quot;)
#
#s = &lt;&lt;EOS
##{
#[1,2,3].join(&quot;,&quot;)
#}
#EOS
#test_ok(s == &quot;1,2,3\n&quot;)
#test_ok(&quot;Just&quot;.to_i(36) == 926381)
#test_ok(&quot;-another&quot;.to_i(36) == -23200231779)
#test_ok(1299022.to_s(36) == &quot;ruby&quot;)
#test_ok(-1045307475.to_s(36) == &quot;-hacker&quot;)
#test_ok(&quot;Just_another_Ruby_hacker&quot;.to_i(36) == 265419172580680477752431643787347)
#test_ok(-265419172580680477752431643787347.to_s(36) == &quot;-justanotherrubyhacker&quot;)
#
#a = []
#(0..255).each {|n|
#  ch = [n].pack(&quot;C&quot;)
#  a.push ch if /a#{Regexp.quote ch}b/x =~ &quot;ab&quot;
#}
#test_ok(a.size == 0)
</pre>
      <pre></pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_iterator.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;iterator&quot;

test_ok(!iterator?)

def ttt
  test_ok(iterator?)
end
ttt{}

# yield at top level
test_ok(!defined?(yield))

$x = [1, 2, 3, 4]
$y = []

# iterator over array
for i in $x
  $y.push i
end
test_ok($x == $y)

# nested iterator
def tt
  1.upto(10) {|i|
    yield i
  }
end

i=0
tt{|i| break if i == 5}
test_ok(i == 0)

def tt2(dummy)
  yield 1
end

def tt3(&amp;block)
  tt2(raise(ArgumentError,&quot;&quot;),&amp;block)
end

$x = false
begin
  tt3{}
rescue ArgumentError
  $x = true
rescue Exception
end
test_ok($x)

def tt4 &amp;block
  tt2(raise(ArgumentError,&quot;&quot;),&amp;block)
end
$x = false
begin
  tt4{}
rescue ArgumentError
  $x = true
rescue Exception
end
test_ok($x)

# iterator break/redo/next/retry
done = true
loop{
  break
  done = false			# should not reach here
}
test_ok(done)

done = false
$bad = false
loop {
  break if done
  done = true
  next
  $bad = true			# should not reach here
}
test_ok(!$bad)

done = false
$bad = false
loop {
  break if done
  done = true
  redo
  $bad = true			# should not reach here
}
test_ok(!$bad)

$x = []
for i in 1 .. 7
  $x.push i
end
test_ok($x.size == 7)
test_ok($x == [1, 2, 3, 4, 5, 6, 7])

# append method to built-in class
class Array
  def iter_test1
    collect{|e| [e, yield(e)]}.sort{|a,b|a[1]&lt;=&gt;b[1]}
  end
  def iter_test2
    a = collect{|e| [e, yield(e)]}
    a.sort{|a,b|a[1]&lt;=&gt;b[1]}
  end
end
$x = [[1,2],[3,4],[5,6]]
test_ok($x.iter_test1{|x|x} == $x.iter_test2{|x|x})

class IterTest
  def initialize(e); @body = e; end

  def each0(&amp;block); @body.each(&amp;block); end
  def each1(&amp;block); @body.each {|*x| block.call(*x) } end
  def each2(&amp;block); @body.each {|*x| block.call(x) } end
  def each3(&amp;block); @body.each {|x| block.call(*x) } end
  def each4(&amp;block); @body.each {|x| block.call(x) } end
  def each5; @body.each {|*x| yield(*x) } end
  def each6; @body.each {|*x| yield(x) } end
  def each7; @body.each {|x| yield(*x) } end
  def each8; @body.each {|x| yield(x) } end

  def f(a)
    a
  end
end
test_ok(IterTest.new(nil).method(:f).to_proc.call([1]) == [1])
m = /\w+/.match(&quot;abc&quot;)
test_ok(IterTest.new(nil).method(:f).to_proc.call([m]) == [m])

IterTest.new([0]).each0 {|x| test_ok(x == 0)}
IterTest.new([1]).each1 {|x| test_ok(x == 1)}
IterTest.new([2]).each2 {|x| test_ok(x == [2])}
#IterTest.new([3]).each3 {|x| test_ok(x == 3)}
IterTest.new([4]).each4 {|x| test_ok(x == 4)}
IterTest.new([5]).each5 {|x| test_ok(x == 5)}
IterTest.new([6]).each6 {|x| test_ok(x == [6])}
#IterTest.new([7]).each7 {|x| test_ok(x == 7)}
IterTest.new([8]).each8 {|x| test_ok(x == 8)}

IterTest.new([[0]]).each0 {|x| test_ok(x == [0])}
IterTest.new([[1]]).each1 {|x| test_ok(x == [1])}
IterTest.new([[2]]).each2 {|x| test_ok(x == [[2]])}
IterTest.new([[3]]).each3 {|x| test_ok(x == 3)}
IterTest.new([[4]]).each4 {|x| test_ok(x == [4])}
IterTest.new([[5]]).each5 {|x| test_ok(x == [5])}
IterTest.new([[6]]).each6 {|x| test_ok(x == [[6]])}
IterTest.new([[7]]).each7 {|x| test_ok(x == 7)}
IterTest.new([[8]]).each8 {|x| test_ok(x == [8])}

IterTest.new([[0,0]]).each0 {|*x| test_ok(x == [[0,0]])}
IterTest.new([[8,8]]).each8 {|*x| test_ok(x == [[8,8]])}

def m0(v)
  v
end

def m1
  m0(block_given?)
end
test_ok(m1{p &#39;test&#39;})
test_ok(!m1)

def m
  m0(block_given?,&amp;Proc.new{})
end
test_ok(m1{p &#39;test&#39;})
test_ok(!m1)

class C
  include Enumerable
  def initialize
    @a = [1,2,3]
  end
  def each(&amp;block)
    @a.each(&amp;block)
  end
end

test_ok(C.new.collect{|n| n} == [1,2,3])

test_ok(Proc == lambda{}.class)
test_ok(Proc == Proc.new{}.class)
lambda{|a|test_ok(a==1)}.call(1)
def block_test(klass, &amp;block)
  test_ok(klass === block)
end

block_test(NilClass)
block_test(Proc){}

def call_argument_test(state, proc, *args)
  x = state
  begin
    proc.call(*args)
  rescue ArgumentError
    x = !x
  end
  test_ok(x,2)
end

call_argument_test(true, lambda{||})
call_argument_test(false, lambda{||}, 1)
call_argument_test(true, lambda{|a,|}, 1)
call_argument_test(false, lambda{|a,|})
call_argument_test(false, lambda{|a,|}, 1,2)

call_argument_test(true, Proc.new{||})
call_argument_test(true, Proc.new{||}, 1)
call_argument_test(true, Proc.new{|a,|}, 1)
call_argument_test(true, Proc.new{|a,|})
call_argument_test(true, Proc.new{|a,|}, 1,2)

def block_get(&amp;block)
  block
end

test_ok(Proc == block_get{}.class)
call_argument_test(true, block_get{||})
call_argument_test(true, block_get{||}, 1)
call_argument_test(true, block_get{|a,|}, 1)
call_argument_test(true, block_get{|a,|})
call_argument_test(true, block_get{|a,|}, 1,2)

call_argument_test(true, block_get(&amp;lambda{||}))
call_argument_test(false, block_get(&amp;lambda{||}),1)
call_argument_test(true, block_get(&amp;lambda{|a,|}),1)
call_argument_test(false, block_get(&amp;lambda{|a,|}),1,2)

blk = block_get{11}
test_ok(blk.class == Proc)
test_ok(blk.to_proc.class == Proc)
test_ok(blk.clone.call == 11)
test_ok(block_get(&amp;blk).class == Proc)

lmd = lambda{44}
test_ok(lmd.class == Proc)
test_ok(lmd.to_proc.class == Proc)
test_ok(lmd.clone.call == 44)
test_ok(block_get(&amp;lmd).class == Proc)

test_ok(Proc.new{|a,| a}.yield(1,2,3) == 1)
call_argument_test(true, Proc.new{|a,|}, 1,2)

test_ok(Proc.new{|&amp;b| b.call(10)}.call {|x| x} == 10)
test_ok(Proc.new{|a,&amp;b| b.call(a)}.call(12) {|x| x} == 12)

def test_return1
  Proc.new {
    return 55
  }.yield + 5
end
test_ok(test_return1() == 55)
def test_return2
  lambda {
    return 55
  }.call + 5
end
test_ok(test_return2() == 60)

def proc_call(&amp;b)
  b.call
end
def proc_yield()
  yield
end
def proc_return1
  lambda{return 42}.call+1
end
test_ok(proc_return1() == 43)
def proc_return2
  -&gt;{return 42}.call+1
end
test_ok(proc_return2() == 43)
def proc_return3
  proc_call{return 42}+1
end
test_ok(proc_return3() == 42)
def proc_return4
  proc_yield{return 42}+1
end
test_ok(proc_return4() == 42)

def ljump_test(state, proc, *args)
  x = state
  begin
    proc.call(*args)
  rescue LocalJumpError
    x = !x
  end
  test_ok(x,2)
end

ljump_test(false, block_get{break})
ljump_test(true, lambda{break})

def exit_value_test(&amp;block)
  block.call
rescue LocalJumpError
  $!.exit_value
end

test_ok(45 == exit_value_test{break 45})

test_ok(55 == begin
              block_get{break 55}.call
            rescue LocalJumpError
              $!.exit_value
            end)

def block_call(&amp;block)
  block.call
end

def test_b1
  block_call{break 11}
end
test_ok(test_b1() == 11)

def ljump_rescue(r)
  begin
    yield
  rescue LocalJumpError =&gt; e
    r if /from proc-closure/ =~ e.message
  end
end

def test_b2
  ljump_rescue(22) do
    block_get{break 21}.call
  end
end
test_ok(test_b2() == 22)

def test_b3
  ljump_rescue(33) do
    Proc.new{break 31}.yield
  end
end
test_ok(test_b3() == 33)

def test_b4
  lambda{break 44}.call
end
test_ok(test_b4() == 44)

def test_b5
  ljump_rescue(55) do
    b = block_get{break 54}
    block_call(&amp;b)
  end
end
test_ok(test_b5() == 55)

def test_b6
  b = lambda{break 67}
  block_call(&amp;b)
  66
end
test_ok(test_b6() == 66)

def util_r7
  block_get{break 78}
end

def test_b7
  b = util_r7()
  ljump_rescue(77) do
    block_call(&amp;b)
  end
end
test_ok(test_b7() == 77)

def util_b8(&amp;block)
  block_call(&amp;block)
end

def test_b8
  util_b8{break 88}
end
test_ok(test_b8() == 88)

def util_b9(&amp;block)
  lambda{block.call; 98}.call
end

def test_b9
  util_b9{break 99}
end
test_ok(test_b9() == 99)

def util_b10
  util_b9{break 100}
end

def test_b10
  util_b10()
end
test_ok(test_b10() == 100)

def test_b11
  ljump_rescue(111) do
    loop do
      Proc.new{break 110}.yield
      break 112
    end
  end
end
test_ok(test_b11() == 111)

def test_b12
  loop do
    break lambda{break 122}.call
    break 121
  end
end
test_ok(test_b12() == 122)

def test_b13
  ljump_rescue(133) do
    while true
      Proc.new{break 130}.yield
      break 131
    end
  end
end
test_ok(test_b13() == 133)

def test_b14
  while true
    break lambda{break 144}.call
    break 143
  end
end
test_ok(test_b14() == 144)

def test_b15
  [0].each {|c| yield 1 }
  156
end
test_ok(test_b15{|e| break 155 } == 155)

def marity_test(m)
  method = method(m)
  test_ok(method.arity == method.to_proc.arity, 2)
end
marity_test(:test_ok)
marity_test(:marity_test)
marity_test(:p)

lambda(&amp;method(:test_ok)).call(true)
lambda(&amp;block_get{|a,n| test_ok(a,n)}).call(true, 2)

class ITER_TEST1
   def a
     block_given?
   end
end

class ITER_TEST2 &lt; ITER_TEST1
   def a
     test_ok(super)
     super
   end
end
test_ok(ITER_TEST2.new.a {})

class ITER_TEST3
  def foo x
    return yield if block_given?
    x
  end
end

class ITER_TEST4 &lt; ITER_TEST3
  def foo x
    test_ok(super == yield)
    test_ok(super(x, &amp;nil) == x)
  end
end

ITER_TEST4.new.foo(44){55}

class ITER_TEST5
   def tt(aa)
     aa
   end

   def uu(a)
      class &lt;&lt; self
         define_method(:tt) do |sym|
            super(sym)
         end
      end
   end

   def xx(*x)
     x.size
   end
end

a = ITER_TEST5.new
a.uu(12)
test_ok(a.tt(1) == 1)

class ITER_TEST6 &lt; ITER_TEST5
   def xx(*a)
      a &lt;&lt; 12
      super
   end
end

test_ok(ITER_TEST6.new.xx([24]) == 2)


</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  
    <div>
      <h2>test_assignment.out</h2>
      <pre style='float: left; width: 50%'>test_check &quot;assignment&quot;

a=[]; a[0] ||= &quot;bar&quot;;
test_ok(a[0] == &quot;bar&quot;)
h={}; h[&quot;foo&quot;] ||= &quot;bar&quot;;
test_ok(h[&quot;foo&quot;] == &quot;bar&quot;)

aa = 5
aa ||= 25
test_ok(aa == 5)
bb ||= 25
test_ok(bb == 25)
cc &amp;&amp;=33
test_ok(cc == nil)
cc = 5
cc &amp;&amp;=44
test_ok(cc == 44)

a = nil; test_ok(a == nil)
a = 1; test_ok(a == 1)
a = []; test_ok(a == [])
a = [1]; test_ok(a == [1])
a = [nil]; test_ok(a == [nil])
a = [[]]; test_ok(a == [[]])
a = [1,2]; test_ok(a == [1,2])
a = [*[]]; test_ok(a == [])
a = [*[1]]; test_ok(a == [1])
a = [*[1,2]]; test_ok(a == [1,2])

a = *[]; test_ok(a == [])
a = *[1]; test_ok(a == [1])
a = *[nil]; test_ok(a == [nil])
a = *[[]]; test_ok(a == [[]])
a = *[1,2]; test_ok(a == [1,2])
a = *[*[]]; test_ok(a == [])
a = *[*[1]]; test_ok(a == [1])
a = *[*[1,2]]; test_ok(a == [1,2])

a, = nil; test_ok(a == nil)
a, = 1; test_ok(a == 1)
a, = []; test_ok(a == nil)
a, = [1]; test_ok(a == 1)
a, = [nil]; test_ok(a == nil)
a, = [[]]; test_ok(a == [])
a, = 1,2; test_ok(a == 1)
a, = [1,2]; test_ok(a == 1)
a, = [*[]]; test_ok(a == nil)
a, = [*[1]]; test_ok(a == 1)
a, = *[1,2]; test_ok(a == 1)
a, = [*[1,2]]; test_ok(a == 1)

a, = *[]; test_ok(a == nil)
a, = *[1]; test_ok(a == 1)
a, = *[nil]; test_ok(a == nil)
a, = *[[]]; test_ok(a == [])
a, = *[1,2]; test_ok(a == 1)
a, = *[*[]]; test_ok(a == nil)
a, = *[*[1]]; test_ok(a == 1)
a, = *[*[1,2]]; test_ok(a == 1)

*a = nil; test_ok(a == [nil])
*a = 1; test_ok(a == [1])
*a = []; test_ok(a == [])
*a = [1]; test_ok(a == [1])
*a = [nil]; test_ok(a == [nil])
*a = [[]]; test_ok(a == [[]])
*a = [1,2]; test_ok(a == [1,2])
*a = [*[]]; test_ok(a == [])
*a = [*[1]]; test_ok(a == [1])
*a = [*[1,2]]; test_ok(a == [1,2])

*a = *[]; test_ok(a == [])
*a = *[1]; test_ok(a == [1])
*a = *[nil]; test_ok(a == [nil])
*a = *[[]]; test_ok(a == [[]])
*a = *[1,2]; test_ok(a == [1,2])
*a = *[*[]]; test_ok(a == [])
*a = *[*[1]]; test_ok(a == [1])
*a = *[*[1,2]]; test_ok(a == [1,2])

a,b,*c = nil; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = 1; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = []; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = [1]; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = [nil]; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = [[]]; test_ok([a,b,c] == [[],nil,[]])
a,b,*c = [1,2]; test_ok([a,b,c] == [1,2,[]])
a,b,*c = [*[]]; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = [*[1]]; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = [*[1,2]]; test_ok([a,b,c] == [1,2,[]])

a,b,*c = *[]; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = *[1]; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = *[nil]; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = *[[]]; test_ok([a,b,c] == [[],nil,[]])
a,b,*c = *[1,2]; test_ok([a,b,c] == [1,2,[]])
a,b,*c = *[*[]]; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = *[*[1]]; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = *[*[1,2]]; test_ok([a,b,c] == [1,2,[]])

def f; yield nil; end; f {|a| test_ok(a == nil)}
def f; yield 1; end; f {|a| test_ok(a == 1)}
def f; yield []; end; f {|a| test_ok(a == [])}
def f; yield [1]; end; f {|a| test_ok(a == [1])}
def f; yield [nil]; end; f {|a| test_ok(a == [nil])}
def f; yield [[]]; end; f {|a| test_ok(a == [[]])}
def f; yield [*[]]; end; f {|a| test_ok(a == [])}
def f; yield [*[1]]; end; f {|a| test_ok(a == [1])}
def f; yield [*[1,2]]; end; f {|a| test_ok(a == [1,2])}
def f; yield *[]; end; f {|a| test_ok(a == nil)}
def f; yield *[1]; end; f {|a| test_ok(a == 1)}
def f; yield *[nil]; end; f {|a| test_ok(a == nil)}
def f; yield *[[]]; end; f {|a| test_ok(a == [])}
def f; yield *[*[]]; end; f {|a| test_ok(a == nil)}
def f; yield *[*[1]]; end; f {|a| test_ok(a == 1)}
def f; yield *[*[1,2]]; end; f {|a| test_ok(a == 1)}

def f; yield; end; f {|a,| test_ok(a == nil)}
def f; yield nil; end; f {|a,| test_ok(a == nil)}
def f; yield 1; end; f {|a,| test_ok(a == 1)}
def f; yield []; end; f {|a,| test_ok(a == nil)}
def f; yield [1]; end; f {|a,| test_ok(a == 1)}
def f; yield [nil]; end; f {|a,| test_ok(a == nil)}
def f; yield [[]]; end; f {|a,| test_ok(a == [])}
def f; yield [*[]]; end; f {|a,| test_ok(a == nil)}
def f; yield [*[1]]; end; f {|a,| test_ok(a == 1)}
def f; yield [*[1,2]]; end; f {|a,| test_ok(a == 1)}

def f; yield *[]; end; f {|a,| test_ok(a == nil)}
def f; yield *[1]; end; f {|a,| test_ok(a == 1)}
def f; yield *[nil]; end; f {|a,| test_ok(a == nil)}
def f; yield *[[]]; end; f {|a,| test_ok(a == nil)}
def f; yield *[*[]]; end; f {|a,| test_ok(a == nil)}
def f; yield *[*[1]]; end; f {|a,| test_ok(a == 1)}
def f; yield *[*[1,2]]; end; f {|a,| test_ok(a == 1)}

def f; yield; end; f {|*a| test_ok(a == [])}
def f; yield nil; end; f {|*a| test_ok(a == [nil])}
def f; yield 1; end; f {|*a| test_ok(a == [1])}
def f; yield []; end; f {|*a| test_ok(a == [[]])}
def f; yield [1]; end; f {|*a| test_ok(a == [[1]])}
def f; yield [nil]; end; f {|*a| test_ok(a == [[nil]])}
def f; yield [[]]; end; f {|*a| test_ok(a == [[[]]])}
def f; yield [1,2]; end; f {|*a| test_ok(a == [[1,2]])}
def f; yield [*[]]; end; f {|*a| test_ok(a == [[]])}
def f; yield [*[1]]; end; f {|*a| test_ok(a == [[1]])}
def f; yield [*[1,2]]; end; f {|*a| test_ok(a == [[1,2]])}

def f; yield *[]; end; f {|*a| test_ok(a == [])}
def f; yield *[1]; end; f {|*a| test_ok(a == [1])}
def f; yield *[nil]; end; f {|*a| test_ok(a == [nil])}
def f; yield *[[]]; end; f {|*a| test_ok(a == [[]])}
def f; yield *[*[]]; end; f {|*a| test_ok(a == [])}
def f; yield *[*[1]]; end; f {|*a| test_ok(a == [1])}
def f; yield *[*[1,2]]; end; f {|*a| test_ok(a == [1,2])}

def f; yield; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield nil; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield 1; end; f {|a,b,*c| test_ok([a,b,c] == [1,nil,[]])}
def f; yield []; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield [1]; end; f {|a,b,*c| test_ok([a,b,c] == [1,nil,[]])}
def f; yield [nil]; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield [[]]; end; f {|a,b,*c| test_ok([a,b,c] == [[],nil,[]])}
def f; yield [*[]]; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield [*[1]]; end; f {|a,b,*c| test_ok([a,b,c] == [1,nil,[]])}
def f; yield [*[1,2]]; end; f {|a,b,*c| test_ok([a,b,c] == [1,2,[]])}

def f; yield *[]; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield *[1]; end; f {|a,b,*c| test_ok([a,b,c] == [1,nil,[]])}
def f; yield *[nil]; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield *[[]]; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield *[*[]]; end; f {|a,b,*c| test_ok([a,b,c] == [nil,nil,[]])}
def f; yield *[*[1]]; end; f {|a,b,*c| test_ok([a,b,c] == [1,nil,[]])}
def f; yield *[*[1,2]]; end; f {|a,b,*c| test_ok([a,b,c] == [1,2,[]])}

def r; return; end; a = r(); test_ok(a == nil)
def r; return nil; end; a = r(); test_ok(a == nil)
def r; return 1; end; a = r(); test_ok(a == 1)
def r; return []; end; a = r(); test_ok(a == [])
def r; return [1]; end; a = r(); test_ok(a == [1])
def r; return [nil]; end; a = r(); test_ok(a == [nil])
def r; return [[]]; end; a = r(); test_ok(a == [[]])
def r; return [*[]]; end; a = r(); test_ok(a == [])
def r; return [*[1]]; end; a = r(); test_ok(a == [1])
def r; return [*[1,2]]; end; a = r(); test_ok(a == [1,2])

def r; return *[]; end; a = r(); test_ok(a == [])
def r; return *[1]; end; a = r(); test_ok(a == [1])
def r; return *[nil]; end; a = r(); test_ok(a == [nil])
def r; return *[[]]; end; a = r(); test_ok(a == [[]])
def r; return *[*[]]; end; a = r(); test_ok(a == [])
def r; return *[*[1]]; end; a = r(); test_ok(a == [1])
def r; return *[*[1,2]]; end; a = r(); test_ok(a == [1,2])

def r; return *[[]]; end; a = *r(); test_ok(a == [[]])
def r; return *[*[1,2]]; end; a = *r(); test_ok(a == [1,2])

def r; return; end; *a = r(); test_ok(a == [nil])
def r; return nil; end; *a = r(); test_ok(a == [nil])
def r; return 1; end; *a = r(); test_ok(a == [1])
def r; return []; end; *a = r(); test_ok(a == [])
def r; return [1]; end; *a = r(); test_ok(a == [1])
def r; return [nil]; end; *a = r(); test_ok(a == [nil])
def r; return [[]]; end; *a = r(); test_ok(a == [[]])
def r; return [1,2]; end; *a = r(); test_ok(a == [1,2])
def r; return [*[]]; end; *a = r(); test_ok(a == [])
def r; return [*[1]]; end; *a = r(); test_ok(a == [1])
def r; return [*[1,2]]; end; *a = r(); test_ok(a == [1,2])

def r; return *[]; end; *a = r(); test_ok(a == [])
def r; return *[1]; end; *a = r(); test_ok(a == [1])
def r; return *[nil]; end; *a = r(); test_ok(a == [nil])
def r; return *[[]]; end; *a = r(); test_ok(a == [[]])
def r; return *[1,2]; end; *a = r(); test_ok(a == [1,2])
def r; return *[*[]]; end; *a = r(); test_ok(a == [])
def r; return *[*[1]]; end; *a = r(); test_ok(a == [1])
def r; return *[*[1,2]]; end; *a = r(); test_ok(a == [1,2])

def r; return *[[]]; end; *a = *r(); test_ok(a == [[]])
def r; return *[1,2]; end; *a = *r(); test_ok(a == [1,2])
def r; return *[*[1,2]]; end; *a = *r(); test_ok(a == [1,2])

def r; return; end; a,b,*c = r(); test_ok([a,b,c] == [nil,nil,[]])
def r; return nil; end; a,b,*c = r(); test_ok([a,b,c] == [nil,nil,[]])
def r; return 1; end; a,b,*c = r(); test_ok([a,b,c] == [1,nil,[]])
def r; return []; end; a,b,*c = r(); test_ok([a,b,c] == [nil,nil,[]])
def r; return [1]; end; a,b,*c = r(); test_ok([a,b,c] == [1,nil,[]])
def r; return [nil]; end; a,b,*c = r(); test_ok([a,b,c] == [nil,nil,[]])
def r; return [[]]; end; a,b,*c = r(); test_ok([a,b,c] == [[],nil,[]])
def r; return [1,2]; end; a,b,*c = r(); test_ok([a,b,c] == [1,2,[]])
def r; return [*[]]; end; a,b,*c = r(); test_ok([a,b,c] == [nil,nil,[]])
def r; return [*[1]]; end; a,b,*c = r(); test_ok([a,b,c] == [1,nil,[]])
def r; return [*[1,2]]; end; a,b,*c = r(); test_ok([a,b,c] == [1,2,[]])

def r; return *[]; end; a,b,*c = r(); test_ok([a,b,c] == [nil,nil,[]])
def r; return *[1]; end; a,b,*c = r(); test_ok([a,b,c] == [1,nil,[]])
def r; return *[nil]; end; a,b,*c = r(); test_ok([a,b,c] == [nil,nil,[]])
def r; return *[[]]; end; a,b,*c = r(); test_ok([a,b,c] == [[],nil,[]])
def r; return *[1,2]; end; a,b,*c = r(); test_ok([a,b,c] == [1,2,[]])
def r; return *[*[]]; end; a,b,*c = r(); test_ok([a,b,c] == [nil,nil,[]])
def r; return *[*[1]]; end; a,b,*c = r(); test_ok([a,b,c] == [1,nil,[]])
def r; return *[*[1,2]]; end; a,b,*c = r(); test_ok([a,b,c] == [1,2,[]])

f = lambda {|r,| test_ok([] == r)}
f.call([], *[])

f = lambda {|r,*l| test_ok([] == r); test_ok([1] == l)}
f.call([], *[1])

f = lambda{|x| x}
test_ok(f.call(42) == 42)
test_ok(f.call([42]) == [42])
test_ok(f.call([[42]]) == [[42]])
test_ok(f.call([42,55]) == [42,55])

f = lambda{|x,| x}
test_ok(f.call(42) == 42)
test_ok(f.call([42]) == [42])
test_ok(f.call([[42]]) == [[42]])
test_ok(f.call([42,55]) == [42,55])

f = lambda{|*x| x}
test_ok(f.call(42) == [42])
test_ok(f.call([42]) == [[42]])
test_ok(f.call([[42]]) == [[[42]]])
test_ok(f.call([42,55]) == [[42,55]])
test_ok(f.call(42,55) == [42,55])

f = lambda { |a, b=42, *c| [a,b,c] }
test_ok(f.call(1      ) == [1,42,[  ]] )
test_ok(f.call(1,43   ) == [1,43,[  ]] )
test_ok(f.call(1,43,44) == [1,43,[44]] )

f = lambda { |a, b=(a|16), *c, &amp;block| [a,b,c,block&amp;&amp;block[]] }
test_ok(f.call(8      )     == [8,24,[  ],nil] )
test_ok(f.call(8,43   )     == [8,43,[  ],nil] )
test_ok(f.call(8,43,44)     == [8,43,[44],nil] )
test_ok(f.call(8      ){45} == [8,24,[  ],45 ] )
test_ok(f.call(8,43   ){45} == [8,43,[  ],45 ] )
test_ok(f.call(8,43,44){45} == [8,43,[44],45 ] )

f = lambda { |a, b=42, *c, d| [a,b,c,d] }
test_ok(f.call(1      ,99) == [1,42,[  ],99] )
test_ok(f.call(1,43   ,99) == [1,43,[  ],99] )
test_ok(f.call(1,43,44,99) == [1,43,[44],99] )

f = lambda { |a, b=(a|16), &amp;block| [a,b,block&amp;&amp;block[]] }
test_ok(f.call(8   )     == [8,24,nil] )
test_ok(f.call(8,43)     == [8,43,nil] )
test_ok(f.call(8,43)     == [8,43,nil] )
test_ok(f.call(8   ){45} == [8,24,45 ] )
test_ok(f.call(8,43){45} == [8,43,45 ] )
test_ok(f.call(8,43){45} == [8,43,45 ] )

f = lambda { |a, b=42, d| [a,b,d] }
test_ok(f.call(1   ,99) == [1,42,99] )
test_ok(f.call(1,43,99) == [1,43,99] )
test_ok(f.call(1,43,99) == [1,43,99] )

f = lambda { |b=42, *c, &amp;block| [b,c,block&amp;&amp;block[]] }
test_ok(f.call(     )     == [42,[  ],nil] )
test_ok(f.call(43   )     == [43,[  ],nil] )
test_ok(f.call(43,44)     == [43,[44],nil] )
test_ok(f.call(     ){45} == [42,[  ],45 ] )
test_ok(f.call(43   ){45} == [43,[  ],45 ] )
test_ok(f.call(43,44){45} == [43,[44],45 ] )

f = lambda { |b=42, *c, d| [b,c,d] }
test_ok(f.call(      99) == [42,[  ],99] )
test_ok(f.call(43   ,99) == [43,[  ],99] )
test_ok(f.call(43,44,99) == [43,[44],99] )

f = lambda { |b=42, &amp;block| [b,block&amp;&amp;block[]] }
test_ok(f.call(  )     == [42,nil] )
test_ok(f.call(43)     == [43,nil] )
test_ok(f.call(43)     == [43,nil] )
test_ok(f.call(  ){45} == [42,45 ] )
test_ok(f.call(43){45} == [43,45 ] )
test_ok(f.call(43){45} == [43,45 ] )

f = lambda { |b=42, d| [b,d] }
test_ok(f.call(   99) == [42,99] )
test_ok(f.call(43,99) == [43,99] )
test_ok(f.call(43,99) == [43,99] )


a,=*[1]
test_ok(a == 1)
a,=*[[1]]
test_ok(a == [1])
a,=*[[[1]]]
test_ok(a == [[1]])

x, (y, z) = 1, 2, 3
test_ok([1,2,nil] == [x,y,z])
x, (y, z) = 1, [2,3]
test_ok([1,2,3] == [x,y,z])
x, (y, z) = 1, [2]
test_ok([1,2,nil] == [x,y,z])

a = loop do break; end; test_ok(a == nil)
a = loop do break nil; end; test_ok(a == nil)
a = loop do break 1; end; test_ok(a == 1)
a = loop do break []; end; test_ok(a == [])
a = loop do break [1]; end; test_ok(a == [1])
a = loop do break [nil]; end; test_ok(a == [nil])
a = loop do break [[]]; end; test_ok(a == [[]])
a = loop do break [*[]]; end; test_ok(a == [])
a = loop do break [*[1]]; end; test_ok(a == [1])
a = loop do break [*[1,2]]; end; test_ok(a == [1,2])

a = loop do break *[]; end; test_ok(a == [])
a = loop do break *[1]; end; test_ok(a == [1])
a = loop do break *[nil]; end; test_ok(a == [nil])
a = loop do break *[[]]; end; test_ok(a == [[]])
a = loop do break *[*[]]; end; test_ok(a == [])
a = loop do break *[*[1]]; end; test_ok(a == [1])
a = loop do break *[*[1,2]]; end; test_ok(a == [1,2])

*a = loop do break; end; test_ok(a == [nil])
*a = loop do break nil; end; test_ok(a == [nil])
*a = loop do break 1; end; test_ok(a == [1])
*a = loop do break []; end; test_ok(a == [])
*a = loop do break [1]; end; test_ok(a == [1])
*a = loop do break [nil]; end; test_ok(a == [nil])
*a = loop do break [[]]; end; test_ok(a == [[]])
*a = loop do break [1,2]; end; test_ok(a == [1,2])
*a = loop do break [*[]]; end; test_ok(a == [])
*a = loop do break [*[1]]; end; test_ok(a == [1])
*a = loop do break [*[1,2]]; end; test_ok(a == [1,2])

*a = loop do break *[]; end; test_ok(a == [])
*a = loop do break *[1]; end; test_ok(a == [1])
*a = loop do break *[nil]; end; test_ok(a == [nil])
*a = loop do break *[[]]; end; test_ok(a == [[]])
*a = loop do break *[1,2]; end; test_ok(a == [1,2])
*a = loop do break *[*[]]; end; test_ok(a == [])
*a = loop do break *[*[1]]; end; test_ok(a == [1])
*a = loop do break *[*[1,2]]; end; test_ok(a == [1,2])

*a = *loop do break *[[]]; end; test_ok(a == [[]])
*a = *loop do break *[1,2]; end; test_ok(a == [1,2])
*a = *loop do break *[*[1,2]]; end; test_ok(a == [1,2])

a,b,*c = loop do break; end; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = loop do break nil; end; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = loop do break 1; end; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = loop do break []; end; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = loop do break [1]; end; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = loop do break [nil]; end; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = loop do break [[]]; end; test_ok([a,b,c] == [[],nil,[]])
a,b,*c = loop do break [1,2]; end; test_ok([a,b,c] == [1,2,[]])
a,b,*c = loop do break [*[]]; end; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = loop do break [*[1]]; end; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = loop do break [*[1,2]]; end; test_ok([a,b,c] == [1,2,[]])

a,b,*c = loop do break *[]; end; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = loop do break *[1]; end; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = loop do break *[nil]; end; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = loop do break *[[]]; end; test_ok([a,b,c] == [[],nil,[]])
a,b,*c = loop do break *[1,2]; end; test_ok([a,b,c] == [1,2,[]])
a,b,*c = loop do break *[*[]]; end; test_ok([a,b,c] == [nil,nil,[]])
a,b,*c = loop do break *[*[1]]; end; test_ok([a,b,c] == [1,nil,[]])
a,b,*c = loop do break *[*[1,2]]; end; test_ok([a,b,c] == [1,2,[]])

def r(val); a = yield(); test_ok(a == val, 2); end
r(nil){next}
r(nil){next nil}
r(1){next 1}
r([]){next []}
r([1]){next [1]}
r([nil]){next [nil]}
r([[]]){next [[]]}
r([]){next [*[]]}
r([1]){next [*[1]]}
r([1,2]){next [*[1,2]]}

r([]){next *[]}
r([1]){next *[1]}
r([nil]){next *[nil]}
r([[]]){next *[[]]}
r([]){next *[*[]]}
r([1]){next *[*[1]]}
r([1,2]){next *[*[1,2]]}

def r(val); *a = yield(); test_ok(a == val, 2); end
r([nil]){next}
r([nil]){next nil}
r([1]){next 1}
r([]){next []}
r([1]){next [1]}
r([nil]){next [nil]}
r([[]]){next [[]]}
r([1,2]){next [1,2]}
r([]){next [*[]]}
r([1]){next [*[1]]}
r([1,2]){next [*[1,2]]}

def r(val); *a = *yield(); test_ok(a == val, 2); end
r([[]]){next *[[]]}
r([1,2]){next *[1,2]}
r([1,2]){next *[*[1,2]]}

def r(val); a,b,*c = yield(); test_ok([a,b,c] == val, 2); end
r([nil,nil,[]]){next}
r([nil,nil,[]]){next nil}
r([1,nil,[]]){next 1}
r([nil,nil,[]]){next []}
r([1,nil,[]]){next [1]}
r([nil,nil,[]]){next [nil]}
r([[],nil,[]]){next [[]]}
r([1,2,[]]){next [1,2]}
r([nil,nil,[]]){next [*[]]}
r([1,nil,[]]){next [*[1]]}
r([1,2,[]]){next [*[1,2]]}

def r(val); a,b,*c = *yield(); test_ok([a,b,c] == val, 2); end
r([[],nil,[]]){next *[[]]}
r([1,2,[]]){next *[1,2]}
r([1,2,[]]){next *[*[1,2]]}
</pre>
      <pre>MRB Load Error (0102_0003)
</pre>
      <br style='clear:both'>
    </div>
  

</body>
</html>

